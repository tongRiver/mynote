{"ID":"20241017204727-yzp41dr","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241017204727-yzp41dr","title":"Python实现A*算法","type":"doc","updated":"20241017212229"},"Children":[{"ID":"20241017204953-1msa6no","Type":"NodeBlockquote","Properties":{"id":"20241017204953-1msa6no","updated":"20241017204953"},"Children":[{"ID":"20241017204727-l1x9t8o","Type":"NodeParagraph","Properties":{"id":"20241017204727-l1x9t8o","updated":"20241017204953"},"Children":[{"Type":"NodeText","Data":"你能用Python实现A*算法吗？具体的要求如下："}]},{"ID":"20241017204904-v0v8lk3","Type":"NodeParagraph","Properties":{"id":"20241017204904-v0v8lk3","updated":"20241017204953"},"Children":[{"Type":"NodeText","Data":"生成一个NxN的二维网格，随机指定一些格子为障碍，并设定左上角有辆无人车（占一个格子）要去右下角，使用A"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"*"}]},{"Type":"NodeText","Data":"算法为该无人车计算起点到终点的不撞到障碍的最优路径"}]},{"Type":"NodeBlockquoteMarker","Data":"\u003e"}]},{"ID":"20241017212156-z8tkjqp","Type":"NodeParagraph","Properties":{"id":"20241017212156-z8tkjqp","updated":"20241017212156"},"Children":[{"Type":"NodeText","Data":"好的，我可以实现一个 A* 算法来解决这个问题。以下是 Python 实现 A* 算法的代码，包括生成随机 NxN 网格、随机障碍物以及计算无人车从左上角到右下角的最优路径。"}]},{"ID":"20241017212156-dmm3gyj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017212156-dmm3gyj","updated":"20241017212156"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"import numpy as np\nimport heapq\nimport matplotlib.pyplot as plt\n\n# 生成随机网格\ndef generate_grid(n, obstacle_ratio=0.2):\n    grid = np.zeros((n, n), dtype=int)\n    num_obstacles = int(n * n * obstacle_ratio)\n    obstacles = np.random.choice(n*n, num_obstacles, replace=False)\n    for idx in obstacles:\n        x, y = divmod(idx, n)\n        if (x, y) not in [(0, 0), (n-1, n-1)]:  # 确保起点和终点不是障碍\n            grid[x, y] = 1  # 1 代表障碍\n    return grid\n\n# A*算法实现\ndef a_star(grid):\n    n = len(grid)\n    start = (0, 0)\n    end = (n-1, n-1)\n\n    # 判断是否在网格范围内\n    def in_bounds(x, y):\n        return 0 \u003c= x \u003c n and 0 \u003c= y \u003c n\n\n    # 获取邻居节点\n    def neighbors(node):\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        result = []\n        for direction in directions:\n            new_x, new_y = node[0] + direction[0], node[1] + direction[1]\n            if in_bounds(new_x, new_y) and grid[new_x, new_y] == 0:\n                result.append((new_x, new_y))\n        return result\n\n    # 计算曼哈顿距离\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    open_list = []\n    heapq.heappush(open_list, (0, start))\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, end)}\n\n    while open_list:\n        _, current = heapq.heappop(open_list)\n\n        if current == end:\n            # 生成路径\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        for neighbor in neighbors(current):\n            tentative_g_score = g_score[current] + 1\n\n            if neighbor not in g_score or tentative_g_score \u003c g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                heapq.heappush(open_list, (f_score[neighbor], neighbor))\n\n    return None  # 没有找到路径\n\n# 显示路径\ndef visualize_path(grid, path):\n    grid = np.copy(grid)\n    for node in path:\n        grid[node] = 2  # 2 代表路径\n\n    plt.imshow(grid, cmap=\"viridis\")\n    plt.title(\"A* Pathfinding\")\n    plt.show()\n\n# 设置网格大小\nN = 10\ngrid = generate_grid(N, obstacle_ratio=0.2)\n\n# 计算路径\npath = a_star(grid)\n\n# 输出结果\nif path:\n    print(\"找到路径:\", path)\n    visualize_path(grid, path)\nelse:\n    print(\"没有找到可行路径。\")\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017212156-xef8x8a","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017212156-xef8x8a","updated":"20241017212156"},"Children":[{"Type":"NodeText","Data":"代码说明"}]},{"ID":"20241017212156-gv6kvry","Type":"NodeList","ListData":{"Typ":1},"Properties":{"id":"20241017212156-gv6kvry","updated":"20241017212156"},"Children":[{"ID":"20241017212156-nwj1sqj","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"MS4=","Num":1},"Properties":{"id":"20241017212156-nwj1sqj","updated":"20241017212156"},"Children":[{"ID":"20241017212156-9bkm58o","Type":"NodeParagraph","Properties":{"id":"20241017212156-9bkm58o","updated":"20241017212156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"generate_grid"},{"Type":"NodeText","Data":" 函数：生成一个随机的 NxN 网格，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"obstacle_ratio"},{"Type":"NodeText","Data":"​ 参数控制障碍物的比例，障碍用 1 表示。"}]}]},{"ID":"20241017212156-0z54flo","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"Mi4=","Num":2},"Properties":{"id":"20241017212156-0z54flo","updated":"20241017212156"},"Children":[{"ID":"20241017212156-p8nuhht","Type":"NodeParagraph","Properties":{"id":"20241017212156-p8nuhht","updated":"20241017212156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"a_star"},{"Type":"NodeText","Data":" 函数：实现 A* 算法，计算从起点 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(0, 0)"},{"Type":"NodeText","Data":"​ 到终点 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(N-1, N-1)"},{"Type":"NodeText","Data":"​ 的最优路径。"}]}]},{"ID":"20241017212156-etamqyx","Type":"NodeListItem","ListData":{"Typ":1,"Delimiter":46,"Marker":"My4=","Num":3},"Properties":{"id":"20241017212156-etamqyx","updated":"20241017212156"},"Children":[{"ID":"20241017212156-b0o69ac","Type":"NodeParagraph","Properties":{"id":"20241017212156-b0o69ac","updated":"20241017212156"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"visualize_path"},{"Type":"NodeText","Data":" 函数：将找到的路径用图形化方式显示出来，路径用 2 表示。"}]}]}]},{"ID":"20241017212156-4kdq2sh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017212156-4kdq2sh","updated":"20241017212216"},"Children":[{"Type":"NodeText","Data":"运行结果"}]},{"ID":"20241017212156-sh981hh","Type":"NodeList","ListData":{},"Properties":{"id":"20241017212156-sh981hh","updated":"20241017212156"},"Children":[{"ID":"20241017212156-pa7rmiu","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212156-pa7rmiu","updated":"20241017212156"},"Children":[{"ID":"20241017212156-nybrttz","Type":"NodeParagraph","Properties":{"id":"20241017212156-nybrttz","updated":"20241017212156"},"Children":[{"Type":"NodeText","Data":"网格中的 0 代表可通行的区域，1 代表障碍物，2 代表找到的路径。"}]}]},{"ID":"20241017212156-m6xa7bv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212156-m6xa7bv","updated":"20241017212156"},"Children":[{"ID":"20241017212156-knibddy","Type":"NodeParagraph","Properties":{"id":"20241017212156-knibddy","updated":"20241017212156"},"Children":[{"Type":"NodeText","Data":"如果存在可行路径，则输出路径并显示网格；否则提示无可行路径。"}]}]}]},{"ID":"20241017212156-42wx3d6","Type":"NodeParagraph","Properties":{"id":"20241017212156-42wx3d6","updated":"20241017212156"},"Children":[{"Type":"NodeText","Data":"你可以直接运行以上代码来测试不同的网格大小和障碍比例。希望这个实现能满足你的需求！如果有其他要求或需要进一步优化，可以告诉我！"}]},{"ID":"20241017212200-90bm9p2","Type":"NodeParagraph","Properties":{"id":"20241017212200-90bm9p2","updated":"20241017212200"}},{"ID":"20241017212201-8jkhrqp","Type":"NodeBlockquote","Properties":{"id":"20241017212201-8jkhrqp","updated":"20241017212210"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20241017212204-pmvrzz2","Type":"NodeParagraph","Properties":{"id":"20241017212204-pmvrzz2","updated":"20241017212210"},"Children":[{"Type":"NodeText","Data":"好的，但是我希望你给a_star函数加上详细的注释，以便让我清楚A*算法是如何实现的"}]}]},{"ID":"20241017212216-25g7jb1","Type":"NodeParagraph","Properties":{"id":"20241017212216-25g7jb1","updated":"20241017212216"},"Children":[{"Type":"NodeText","Data":"当然可以，我会在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a_star"},{"Type":"NodeText","Data":"​ 函数中添加详细的注释，帮助你更好地理解 A* 算法的实现过程。"}]},{"ID":"20241017212216-ald88j0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017212216-ald88j0","updated":"20241017212216"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"import numpy as np\nimport heapq\nimport matplotlib.pyplot as plt\n\n# 生成随机网格\ndef generate_grid(n, obstacle_ratio=0.2):\n    grid = np.zeros((n, n), dtype=int)\n    num_obstacles = int(n * n * obstacle_ratio)\n    obstacles = np.random.choice(n*n, num_obstacles, replace=False)\n    for idx in obstacles:\n        x, y = divmod(idx, n)\n        if (x, y) not in [(0, 0), (n-1, n-1)]:  # 确保起点和终点不是障碍\n            grid[x, y] = 1  # 1 代表障碍\n    return grid\n\n# A*算法实现\ndef a_star(grid):\n    n = len(grid)\n    start = (0, 0)\n    end = (n-1, n-1)\n\n    # 辅助函数：判断是否在网格范围内\n    def in_bounds(x, y):\n        return 0 \u003c= x \u003c n and 0 \u003c= y \u003c n\n\n    # 辅助函数：获取当前节点的邻居节点\n    def neighbors(node):\n        # 四个可能的方向：上、下、左、右\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        result = []\n        for direction in directions:\n            new_x, new_y = node[0] + direction[0], node[1] + direction[1]\n            # 如果邻居节点在网格范围内并且不是障碍，加入结果集\n            if in_bounds(new_x, new_y) and grid[new_x, new_y] == 0:\n                result.append((new_x, new_y))\n        return result\n\n    # 辅助函数：计算启发函数（h）的曼哈顿距离\n    def heuristic(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    # 初始化优先队列（open_list）\n    open_list = []\n    heapq.heappush(open_list, (0, start))\n    came_from = {}\n  \n    # g_score 为当前起点到该节点的代价，初始化为无穷大\n    g_score = {start: 0}\n  \n    # f_score 是对节点的总估计代价，包括从起点经过该节点到终点的估计，总为 g_score + heuristic\n    f_score = {start: heuristic(start, end)}\n\n    # A* 核心循环\n    while open_list:\n        # 从优先队列中取出 f_score 最小的节点进行处理\n        _, current = heapq.heappop(open_list)\n\n        # 如果到达终点，构建并返回路径\n        if current == end:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n\n        # 遍历当前节点的每一个邻居\n        for neighbor in neighbors(current):\n            # 计算到邻居节点的临时代价\n            tentative_g_score = g_score[current] + 1\n\n            # 如果这条路径到邻居节点更短，则更新其代价\n            if neighbor not in g_score or tentative_g_score \u003c g_score[neighbor]:\n                # 记录经过当前节点到达邻居节点的路径\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, end)\n                # 将邻居节点加入优先队列中以便处理（优先 f_score 较小者）\n                heapq.heappush(open_list, (f_score[neighbor], neighbor))\n\n    # 如果没有找到路径，返回 None\n    return None\n\n# 显示路径\ndef visualize_path(grid, path):\n    grid = np.copy(grid)\n    for node in path:\n        grid[node] = 2  # 2 代表路径\n\n    plt.imshow(grid, cmap=\"viridis\")\n    plt.title(\"A* Pathfinding\")\n    plt.show()\n\n# 设置网格大小\nN = 10\ngrid = generate_grid(N, obstacle_ratio=0.2)\n\n# 计算路径\npath = a_star(grid)\n\n# 输出结果\nif path:\n    print(\"找到路径:\", path)\n    visualize_path(grid, path)\nelse:\n    print(\"没有找到可行路径。\")\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017212216-d6k3c8i","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017212216-d6k3c8i","updated":"20241017212229"},"Children":[{"Type":"NodeText","Data":"A* 算法说明"}]},{"ID":"20241017212216-kexnfzg","Type":"NodeList","ListData":{},"Properties":{"id":"20241017212216-kexnfzg","updated":"20241017212216"},"Children":[{"ID":"20241017212216-63tntel","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212216-63tntel","updated":"20241017212216"},"Children":[{"ID":"20241017212216-2iksebl","Type":"NodeParagraph","Properties":{"id":"20241017212216-2iksebl","updated":"20241017212216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Open List"},{"Type":"NodeText","Data":": 用于存储将要被访问的节点。"}]}]},{"ID":"20241017212216-58pbvqv","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212216-58pbvqv","updated":"20241017212216"},"Children":[{"ID":"20241017212216-xkx7mzq","Type":"NodeParagraph","Properties":{"id":"20241017212216-xkx7mzq","updated":"20241017212216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"g_score"},{"Type":"NodeText","Data":": 记录从起始节点到当前节点的实际代价。"}]}]},{"ID":"20241017212216-36dgxt1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212216-36dgxt1","updated":"20241017212216"},"Children":[{"ID":"20241017212216-kyiqxvx","Type":"NodeParagraph","Properties":{"id":"20241017212216-kyiqxvx","updated":"20241017212216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"f_score"},{"Type":"NodeText","Data":": 用于估计从起始节点经过当前节点到目标节点的总代价。"}]}]},{"ID":"20241017212216-64ep8le","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212216-64ep8le","updated":"20241017212216"},"Children":[{"ID":"20241017212216-ojbtxcz","Type":"NodeParagraph","Properties":{"id":"20241017212216-ojbtxcz","updated":"20241017212216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Heuristic Function (h)"},{"Type":"NodeText","Data":": 使用曼哈顿距离计算当前节点到目标节点的估计代价。"}]}]},{"ID":"20241017212216-x9yvxfg","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017212216-x9yvxfg","updated":"20241017212216"},"Children":[{"ID":"20241017212216-zmwv80s","Type":"NodeParagraph","Properties":{"id":"20241017212216-zmwv80s","updated":"20241017212216"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"路径重建"},{"Type":"NodeText","Data":": 一旦找到目标节点，通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"came_from"},{"Type":"NodeText","Data":"​ 记录回溯路径。"}]}]}]},{"ID":"20241017212216-6icvy7k","Type":"NodeParagraph","Properties":{"id":"20241017212216-6icvy7k","updated":"20241017212216"},"Children":[{"Type":"NodeText","Data":"该实现包括了找到最优路径所需的所有步骤和数据结构，希望这些注释能帮助你更好地理解 A* 算法的工作机制！如果还有问题，请随时问我。"}]},{"ID":"20241017212229-jx3iow5","Type":"NodeParagraph","Properties":{"id":"20241017212229-jx3iow5","updated":"20241017212229"}}]}