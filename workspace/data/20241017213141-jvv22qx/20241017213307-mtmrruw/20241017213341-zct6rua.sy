{"ID":"20241017213341-zct6rua","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241017213341-zct6rua","title":"Python使用优先队列","type":"doc","updated":"20241021155651"},"Children":[{"ID":"20241017213408-b0ovi18","Type":"NodeParagraph","Properties":{"id":"20241017213408-b0ovi18","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"在 Python 中，优先队列（Priority Queue）通常可以通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 模块来实现。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 是一个基于堆（heap）的实现，堆是一种特殊的二叉树，最小堆的根节点是最小元素，因此它也叫做"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"最小优先队列"},{"Type":"NodeText","Data":"。"}]},{"ID":"20241017213408-fjpbap7","Type":"NodeParagraph","Properties":{"id":"20241017213408-fjpbap7","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"以下是使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 实现优先队列的步骤："}]},{"ID":"20241017213408-6slsdqw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-6slsdqw","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"1. 导入 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 模块"}]},{"ID":"20241017213408-flvh28t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-flvh28t","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"import heapq\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-v5rq4nx","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-v5rq4nx","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"2. 使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 创建优先队列"}]},{"ID":"20241017213408-46z1o63","Type":"NodeParagraph","Properties":{"id":"20241017213408-46z1o63","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 实际上是对列表进行操作的，因此我们只需要创建一个空列表，然后使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 提供的函数来操作它。"}]},{"ID":"20241017213408-aqehjr4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-aqehjr4","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"pq = []  # 创建一个空的优先队列\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-6y4863c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-6y4863c","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"3. 向优先队列中添加元素"}]},{"ID":"20241017213408-ngey3ld","Type":"NodeParagraph","Properties":{"id":"20241017213408-ngey3ld","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"我们可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heappush()"},{"Type":"NodeText","Data":"​ 将元素加入优先队列。该函数会将元素放到适当的位置，保持堆的特性（最小堆）。"}]},{"ID":"20241017213408-bircmx5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-bircmx5","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"heapq.heappush(pq, 5)\nheapq.heappush(pq, 1)\nheapq.heappush(pq, 3)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-pgcfgvi","Type":"NodeParagraph","Properties":{"id":"20241017213408-pgcfgvi","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"此时 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pq"},{"Type":"NodeText","Data":"​ 中的元素排列为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[1, 5, 3]"},{"Type":"NodeText","Data":"​，但是 Python 的堆是内部排序的，它只保证 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pq[0]"},{"Type":"NodeText","Data":"​ 是最小的元素，整体顺序不一定是完全排序的。"}]},{"ID":"20241017213408-egrfrpf","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-egrfrpf","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"4. 从优先队列中取出最小元素"}]},{"ID":"20241017213408-l5yubt4","Type":"NodeParagraph","Properties":{"id":"20241017213408-l5yubt4","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heappop()"},{"Type":"NodeText","Data":"​ 可以弹出并返回队列中的最小元素。"}]},{"ID":"20241017213408-dix016a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-dix016a","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"min_element = heapq.heappop(pq)\nprint(min_element)  # 输出1\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-kss1o20","Type":"NodeParagraph","Properties":{"id":"20241017213408-kss1o20","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"每次调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heappop()"},{"Type":"NodeText","Data":"​ 时，都会将队列中的最小元素移除，并调整剩余元素的位置。"}]},{"ID":"20241017213408-qsmigxm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-qsmigxm","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"5. 查看优先队列中的最小元素（不删除）"}]},{"ID":"20241017213408-ivejef8","Type":"NodeParagraph","Properties":{"id":"20241017213408-ivejef8","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"如果只想查看最小元素而不删除它，可以直接访问列表的第一个元素："}]},{"ID":"20241017213408-xlw1mq6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-xlw1mq6","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"min_element = pq[0]\nprint(min_element)\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-gl331hz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-gl331hz","updated":"20241017214037"},"Children":[{"Type":"NodeText","Data":"6. 使用优先级来处理复杂对象🌸"}]},{"ID":"20241017213408-5hyxn3w","Type":"NodeParagraph","Properties":{"id":"20241017213408-5hyxn3w","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"如果你有更复杂的数据结构，比如想根据对象的某个属性来定义优先级，可以使用元组 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"(priority, item)"},{"Type":"NodeText","Data":"​ 的形式，优先队列会根据第一个元素（"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"priority"},{"Type":"NodeText","Data":"​）进行排序。"}]},{"ID":"20241017213408-l4bz8o9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-l4bz8o9","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"heapq.heappush(pq, (2, 'task 2'))\nheapq.heappush(pq, (1, 'task 1'))\nheapq.heappush(pq, (3, 'task 3'))\n\n# 弹出优先级最高（数值最小）的任务\nnext_task = heapq.heappop(pq)\nprint(next_task)  # 输出 (1, 'task 1')\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-f8krulu","Type":"NodeParagraph","Properties":{"id":"20241017213408-f8krulu","updated":"20241017214037"},"Children":[{"Type":"NodeText","Data":"这里"},{"Type":"NodeTextMark","TextMarkType":"mark","TextMarkTextContent":"优先级为数值越小越优先"},{"Type":"NodeText","Data":"。"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heappop()"},{"Type":"NodeText","Data":"​ 会返回优先级最低（即数值最小）的元素。"}]},{"ID":"20241017213408-fxbgpia","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-fxbgpia","updated":"20241017232401"},"Children":[{"Type":"NodeText","Data":"7. 将一个列表转化为堆🌸"}]},{"ID":"20241017213408-yuva4bt","Type":"NodeParagraph","Properties":{"id":"20241017213408-yuva4bt","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"如果你已经有一个列表，想将其直接转化为堆，可以使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heapify()"},{"Type":"NodeText","Data":"​。"}]},{"ID":"20241017213408-2q8gtxr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241017213408-2q8gtxr","updated":"20241017213408"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cHl0aG9u"},{"Type":"NodeCodeBlockCode","Data":"data = [5, 1, 3, 7, 8]\nheapq.heapify(data)\nprint(data)  # 输出为堆的形式，例如 [1, 5, 3, 7, 8]\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20241017213408-0v9sbm9","Type":"NodeParagraph","Properties":{"id":"20241017213408-0v9sbm9","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heapify()"},{"Type":"NodeText","Data":"​ 会将一个普通的列表就地转化为堆。"}]},{"ID":"20241017213408-rbt71y9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241017213408-rbt71y9","updated":"20241017213410"},"Children":[{"Type":"NodeText","Data":"8. 总结常用的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq"},{"Type":"NodeText","Data":"​ 函数"}]},{"ID":"20241017213408-qhnsvpm","Type":"NodeList","ListData":{},"Properties":{"id":"20241017213408-qhnsvpm","updated":"20241017213408"},"Children":[{"ID":"20241017213408-j8a710h","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017213408-j8a710h","updated":"20241017213408"},"Children":[{"ID":"20241017213408-eti8bh1","Type":"NodeParagraph","Properties":{"id":"20241017213408-eti8bh1","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heappush(heap, item)"},{"Type":"NodeText","Data":"​：将元素 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"item"},{"Type":"NodeText","Data":"​ 推入堆中。"}]}]},{"ID":"20241017213408-7qjicmk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017213408-7qjicmk","updated":"20241017213408"},"Children":[{"ID":"20241017213408-w1edysv","Type":"NodeParagraph","Properties":{"id":"20241017213408-w1edysv","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heappop(heap)"},{"Type":"NodeText","Data":"​：弹出并返回堆中的最小元素。"}]}]},{"ID":"20241017213408-9mg456l","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017213408-9mg456l","updated":"20241017213408"},"Children":[{"ID":"20241017213408-ijhxm0b","Type":"NodeParagraph","Properties":{"id":"20241017213408-ijhxm0b","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heapify(list)"},{"Type":"NodeText","Data":"​：将一个列表就地转化为堆。"}]}]},{"ID":"20241017213408-ecpj8fk","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017213408-ecpj8fk","updated":"20241017213408"},"Children":[{"ID":"20241017213408-d9tyy4s","Type":"NodeParagraph","Properties":{"id":"20241017213408-d9tyy4s","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heappushpop(heap, item)"},{"Type":"NodeText","Data":"​：将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"item"},{"Type":"NodeText","Data":"​ 推入堆中，然后弹出并返回堆中的最小元素（效率更高）。"}]}]},{"ID":"20241017213408-xcuc9fq","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241017213408-xcuc9fq","updated":"20241017213408"},"Children":[{"ID":"20241017213408-4f58gz2","Type":"NodeParagraph","Properties":{"id":"20241017213408-4f58gz2","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"heapq.heapreplace(heap, item)"},{"Type":"NodeText","Data":"​：弹出堆中最小元素，并将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"item"},{"Type":"NodeText","Data":"​ 推入堆中（效率更高）。"}]}]}]},{"ID":"20241017213408-kh12td8","Type":"NodeParagraph","Properties":{"id":"20241017213408-kh12td8","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"优先队列在处理需要动态维护最小/最大值的场景非常有用，比如任务调度、最短路径算法等。"}]},{"ID":"20241017213408-sos4wie","Type":"NodeParagraph","Properties":{"id":"20241017213408-sos4wie","updated":"20241017213408"},"Children":[{"Type":"NodeText","Data":"如果有更多问题，欢迎继续提问！"}]},{"ID":"20241017213410-hc9b2ba","Type":"NodeParagraph","Properties":{"id":"20241017213410-hc9b2ba","updated":"20241017213410"}}]}