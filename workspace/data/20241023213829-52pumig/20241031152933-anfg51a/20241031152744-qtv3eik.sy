{"ID":"20241031152744-qtv3eik","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241031152744-qtv3eik","title":"进程","type":"doc","updated":"20241031153334"},"Children":[{"ID":"20241031152745-03715b0","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241031152745-03715b0","updated":"20241031152745"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"创建进程"}]},{"ID":"20241031152746-ddfph22","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152746-ddfph22","updated":"20241031152746"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"一、Linux的0、1和2号进程"}]},{"ID":"20241031152747-ulvyvam","Type":"NodeParagraph","Properties":{"id":"20241031152747-ulvyvam","updated":"20241031152747"},"Children":[{"Type":"NodeText","Data":"整个linux系统全部的进程是一个树形结构。"}]},{"ID":"20241031152748-yr07wyk","Type":"NodeParagraph","Properties":{"id":"20241031152748-yr07wyk","updated":"20241031152748"},"Children":[{"Type":"NodeText","Data":"0号进程（系统进程）是所有进程的祖先，它创建了1号和2号进程。"}]},{"ID":"20241031152749-vtog6lr","Type":"NodeParagraph","Properties":{"id":"20241031152749-vtog6lr","updated":"20241031152749"},"Children":[{"Type":"NodeText","Data":"1号进程（systemd）负责执行内核的初始化工作和进行系统配置。"}]},{"ID":"20241031152750-1tewqh8","Type":"NodeParagraph","Properties":{"id":"20241031152750-1tewqh8","updated":"20241031152750"},"Children":[{"Type":"NodeText","Data":"2号进程（kthreadd）负责所有内核线程的调度和管理。"}]},{"ID":"20241031152751-n1djvi1","Type":"NodeParagraph","Properties":{"id":"20241031152751-n1djvi1","updated":"20241031152751"},"Children":[{"Type":"NodeText","Data":"用pstree命令可以查看进程树（yum -y install psmisc）。"}]},{"ID":"20241031152752-ksoabf6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"YmFzaA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152752-ksoabf6","updated":"20241031152752"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"YmFzaA==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"pstree -p 进程编号\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152753-x5y58kr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152753-x5y58kr","updated":"20241031152753"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"二、进程标识"}]},{"ID":"20241031152754-9278g1z","Type":"NodeParagraph","Properties":{"id":"20241031152754-9278g1z","updated":"20241031152754"},"Children":[{"Type":"NodeText","Data":"每个进程都有一个非负整数表示的唯一的进程ID。虽然是唯一的，但是进程ID可以复用。当一个进程终止后，其进程ID就成了复用的候选者。Linux采用延迟复用算法，让新建进程的ID不同于最近终止的进程所使用的ID。这样防止了新进程被误认为是使用了同一ID的某个已终止的进程。"}]},{"ID":"20241031152755-koggzsk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152755-koggzsk","updated":"20241031152755"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"pid_t getpid(void);   // 获取当前进程的ID。\n\npid_t getppid(void);  // 获取父进程的ID。\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152756-6fl6w6n","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152756-6fl6w6n","updated":"20241031152756"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"补充：父进程与子进程🌞"}]},{"ID":"20241031152757-tplkuh4","Type":"NodeBlockquote","Properties":{"id":"20241031152757-tplkuh4","updated":"20241031152757"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241031152758-41nirzw","Type":"NodeParagraph","Properties":{"id":"20241031152758-41nirzw","updated":"20241031152758"},"Children":[{"Type":"NodeText","Data":"父进程和子进程的关系是什么？它们共享内存空间吗？"}]}]},{"ID":"20241031152759-giabqml","Type":"NodeParagraph","Properties":{"id":"20241031152759-giabqml","updated":"20241031152759"},"Children":[{"Type":"NodeText","Data":"父进程和子进程的关系通常是由一个进程通过系统调用（如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 在 Unix 和 Linux 系统中）创建另一个进程而形成的。创建进程被称为父进程，而新创建的进程被称为子进程。"}]},{"ID":"20241031152760-220p3mu","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241031152760-220p3mu","updated":"20241031152760"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"父进程和子进程的关系："}]},{"ID":"20241031152761-r3h9yeq","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152761-r3h9yeq","updated":"20241031152761"},"Children":[{"ID":"20241031152762-rg83ho2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152762-rg83ho2","updated":"20241031152762"},"Children":[{"ID":"20241031152763-fv15qnv","Type":"NodeParagraph","Properties":{"id":"20241031152763-fv15qnv","updated":"20241031152763"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"继承关系"},{"Type":"NodeText","Data":"：子进程继承父进程的大部分环境，包括文件描述符、环境变量、当前工作目录、用户ID、组ID等。"}]}]},{"ID":"20241031152764-yh452fj","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241031152764-yh452fj","updated":"20241031152764"},"Children":[{"ID":"20241031152765-oumqoj1","Type":"NodeParagraph","Properties":{"id":"20241031152765-oumqoj1","updated":"20241031152765"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"独立的执行流"},{"Type":"NodeText","Data":"：子进程有自己独立的执行流，它会从父进程执行 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 的地方开始执行，但在逻辑上与父进程是分开的。"}]}]},{"ID":"20241031152766-0c6jm3o","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241031152766-0c6jm3o","updated":"20241031152766"},"Children":[{"ID":"20241031152767-n1w9wgc","Type":"NodeParagraph","Properties":{"id":"20241031152767-n1w9wgc","updated":"20241031152767"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"父子进程的生命周期"},{"Type":"NodeText","Data":"：通常子进程的生命周期与父进程有关，当父进程终止时，子进程可能会被操作系统收养（变成孤儿进程），由 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"init"},{"Type":"NodeText","Data":" 进程接管。"}]}]}]},{"ID":"20241031152768-lfb30h6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241031152768-lfb30h6","updated":"20241031152768"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"内存空间："}]},{"ID":"20241031152769-yf3jj2a","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152769-yf3jj2a","updated":"20241031152769"},"Children":[{"ID":"20241031152770-nm0yxs9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152770-nm0yxs9","updated":"20241031152770"},"Children":[{"ID":"20241031152771-l47d7zi","Type":"NodeParagraph","Properties":{"id":"20241031152771-l47d7zi","updated":"20241031152771"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存空间不共享"},{"Type":"NodeText","Data":"：父进程和子进程"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不共享"},{"Type":"NodeText","Data":"内存空间。虽然子进程在创建时会复制父进程的整个地址空间（包括数据段、堆、栈等），但父子进程在之后的执行过程中有各自独立的内存空间。对一方内存的修改不会影响到另一方。"}]}]},{"ID":"20241031152772-4tu5imh","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152772-4tu5imh","updated":"20241031152772"},"Children":[{"ID":"20241031152773-oelyz7m","Type":"NodeParagraph","Properties":{"id":"20241031152773-oelyz7m","updated":"20241031152773"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"写时复制 (Copy-On-Write, COW)"},{"Type":"NodeText","Data":"：现代操作系统通常采用“写时复制”技术，在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 时不会立即复制整个内存空间，而是仅在子进程或父进程尝试修改内存时，才真正复制那部分内存，这样做的目的是提高效率。"}]}]}]},{"ID":"20241031152774-klswtoq","Type":"NodeParagraph","Properties":{"id":"20241031152774-klswtoq","updated":"20241031152774"},"Children":[{"Type":"NodeText","Data":"总结来说，父进程和子进程虽然有继承关系，但它们各自拥有独立的内存空间，并不会共享整个内存空间。"}]},{"ID":"20241031152775-i1o35c5","Type":"NodeBlockquote","Properties":{"id":"20241031152775-i1o35c5","updated":"20241031152775"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241031152776-fyuip03","Type":"NodeParagraph","Properties":{"id":"20241031152776-fyuip03","updated":"20241031152776"},"Children":[{"Type":"NodeText","Data":"好的，那么以Linux下的c++程序为例，如果对父进程和子进程中相同的变量取地址，得到的地址值是一样的吗？"}]}]},{"ID":"20241031152777-sznmo65","Type":"NodeParagraph","Properties":{"id":"20241031152777-sznmo65","updated":"20241031152777"},"Children":[{"Type":"NodeText","Data":"在 Linux 下的 C++ 程序中，父进程和子进程在调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 后各自拥有独立的内存空间。如果你在父进程和子进程中对相同变量取地址，虽然它们在各自进程内存空间中的位置相同，但由于内存空间是独立的，这两个地址值"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"在逻辑上相同，但在实际意义上不同"},{"Type":"NodeText","Data":"。"}]},{"ID":"20241031152778-xgju8ya","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241031152778-xgju8ya","updated":"20241031152778"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"相同变量的地址"}]},{"ID":"20241031152779-iaiwxwe","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152779-iaiwxwe","updated":"20241031152779"},"Children":[{"ID":"20241031152780-08gxd18","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152780-08gxd18","updated":"20241031152780"},"Children":[{"ID":"20241031152781-r1g0u8c","Type":"NodeParagraph","Properties":{"id":"20241031152781-r1g0u8c","updated":"20241031152781"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"逻辑地址相同"},{"Type":"NodeText","Data":"：在父进程和子进程中，相同的变量在各自进程的内存地址（逻辑地址）中具有相同的值。这是因为子进程是父进程的拷贝，其内存布局在逻辑上是一致的。"}]}]},{"ID":"20241031152782-23qaau7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152782-23qaau7","updated":"20241031152782"},"Children":[{"ID":"20241031152783-vg1ba0p","Type":"NodeParagraph","Properties":{"id":"20241031152783-vg1ba0p","updated":"20241031152783"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"物理地址不同"},{"Type":"NodeText","Data":"：由于父进程和子进程有独立的内存空间，操作系统会为这两个进程分配不同的物理内存。因此，即使变量的逻辑地址相同，它们在物理内存中的地址可能是不同的。"}]}]}]},{"ID":"20241031152784-100ycc6","Type":"NodeParagraph","Properties":{"id":"20241031152784-100ycc6","updated":"20241031152784"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"举个例子："}]},{"ID":"20241031152785-2arjc1p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152785-2arjc1p","updated":"20241031152785"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cunistd.h\u003e\n\nint main() {\n    int var = 42;\n    \n    pid_t pid = fork();\n\n    if (pid == 0) { // 子进程\n        std::cout \u003c\u003c \"Child process, var address: \" \u003c\u003c \u0026var \u003c\u003c std::endl;\n    } else { // 父进程\n        std::cout \u003c\u003c \"Parent process, var address: \" \u003c\u003c \u0026var \u003c\u003c std::endl;\n    }\n    \n    return 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152786-i3g7sby","Type":"NodeParagraph","Properties":{"id":"20241031152786-i3g7sby","updated":"20241031152786"},"Children":[{"Type":"NodeText","Data":"在这个例子中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 之后，父进程和子进程中变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"var"},{"Type":"NodeText","Data":" 的地址 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"\u0026amp;var"},{"Type":"NodeText","Data":" 会显示为相同的值（逻辑地址相同），但这只是它们在各自进程中的逻辑地址相同，实际的物理地址不同。"}]},{"ID":"20241031152787-4qpjcx5","Type":"NodeParagraph","Properties":{"id":"20241031152787-4qpjcx5","updated":"20241031152787"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"总结"},{"Type":"NodeText","Data":"：父进程和子进程中相同变量的地址值（逻辑地址）看似一样，但它们实际位于不同的物理内存中。因此，虽然地址值相同，但这两个地址引用的物理内存区域是不同的。"}]},{"ID":"20241031152788-pt359zd","Type":"NodeBlockquote","Properties":{"id":"20241031152788-pt359zd","updated":"20241031152788"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241031152789-enf57c0","Type":"NodeParagraph","Properties":{"id":"20241031152789-enf57c0","updated":"20241031152789"},"Children":[{"Type":"NodeText","Data":"明白了，那么你能再多讲讲父子进程中的写时复制吗？我想详细了解它"}]}]},{"ID":"20241031152790-xqwvprm","Type":"NodeParagraph","Properties":{"id":"20241031152790-xqwvprm","updated":"20241031152790"},"Children":[{"Type":"NodeText","Data":"写时复制（Copy-On-Write，COW）是一种操作系统的内存管理技术，它在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 系统调用之后用于优化内存使用效率。写时复制的核心思想是推迟内存的复制操作，直到有必要时才进行实际的物理内存分配和复制。"}]},{"ID":"20241031152791-wqo1sru","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241031152791-wqo1sru","updated":"20241031152791"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"写时复制的工作原理"}]},{"ID":"20241031152792-3hmidcu","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152792-3hmidcu","updated":"20241031152792"},"Children":[{"ID":"20241031152793-8dde3ns","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152793-8dde3ns","updated":"20241031152793"},"Children":[{"ID":"20241031152794-l5wufmr","Type":"NodeParagraph","Properties":{"id":"20241031152794-l5wufmr","updated":"20241031152794"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"fork()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 系统调用"},{"Type":"NodeText","Data":"："}]},{"ID":"20241031152795-vkyz17v","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152795-vkyz17v","updated":"20241031152795"},"Children":[{"ID":"20241031152796-zwg8877","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152796-zwg8877","updated":"20241031152796"},"Children":[{"ID":"20241031152797-a2iots7","Type":"NodeParagraph","Properties":{"id":"20241031152797-a2iots7","updated":"20241031152797"},"Children":[{"Type":"NodeText","Data":"当一个进程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 时，操作系统会创建一个子进程，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"子进程会继承父进程的地址空间的副本"},{"Type":"NodeText","Data":"。在传统方式下，这意味着要复制父进程的整个内存空间（包括堆、栈、全局变量等），这在实际应用中非常低效，尤其是当父进程有大量的内存或者子进程只是立即执行了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"exec()"},{"Type":"NodeText","Data":" 覆盖自己的地址空间时。"}]}]}]}]},{"ID":"20241031152798-zxco0t6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241031152798-zxco0t6","updated":"20241031152798"},"Children":[{"ID":"20241031152799-lu5t8ft","Type":"NodeParagraph","Properties":{"id":"20241031152799-lu5t8ft","updated":"20241031152799"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"共享内存页"},{"Type":"NodeText","Data":"："}]},{"ID":"20241031152800-8mkmtwm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152800-8mkmtwm","updated":"20241031152800"},"Children":[{"ID":"20241031152801-ga9oq0g","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152801-ga9oq0g","updated":"20241031152801"},"Children":[{"ID":"20241031152802-nva133u","Type":"NodeParagraph","Properties":{"id":"20241031152802-nva133u","updated":"20241031152802"},"Children":[{"Type":"NodeText","Data":"为了提高效率，写时复制机制避免了直接复制内存。相反，父进程和子进程在最初会共享相同的物理内存页。这些共享的内存页在操作系统的页面表中标记为只读。这意味着父进程和子进程都可以读取这些内存页，但不能直接写入。"}]}]}]}]},{"ID":"20241031152803-vscvdao","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241031152803-vscvdao","updated":"20241031152803"},"Children":[{"ID":"20241031152804-no9ik67","Type":"NodeParagraph","Properties":{"id":"20241031152804-no9ik67","updated":"20241031152804"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"页面保护和实际复制"},{"Type":"NodeText","Data":"："}]},{"ID":"20241031152805-hok8ecp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152805-hok8ecp","updated":"20241031152805"},"Children":[{"ID":"20241031152806-9ddf43h","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152806-9ddf43h","updated":"20241031152806"},"Children":[{"ID":"20241031152807-bl8zdaw","Type":"NodeParagraph","Properties":{"id":"20241031152807-bl8zdaw","updated":"20241031152807"},"Children":[{"Type":"NodeText","Data":"当父进程或子进程尝试修改这些共享的内存页时，处理器会检测到写入操作，并触发一个页面错误（page fault）。操作系统接收到这个页面错误后，会复制要修改的内存页，从而为请求写入的进程分配一个新的、独立的物理页。这时，修改操作会在新复制的页上进行，而原始的内存页仍然保持不变，并继续与其他进程共享（如果有必要的话）。"}]}]}]}]},{"ID":"20241031152808-cfsgonv","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20241031152808-cfsgonv","updated":"20241031152808"},"Children":[{"ID":"20241031152809-rpcnuf2","Type":"NodeParagraph","Properties":{"id":"20241031152809-rpcnuf2","updated":"20241031152809"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存使用优化"},{"Type":"NodeText","Data":"："}]},{"ID":"20241031152810-clmsig3","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152810-clmsig3","updated":"20241031152810"},"Children":[{"ID":"20241031152811-bzxwclk","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152811-bzxwclk","updated":"20241031152811"},"Children":[{"ID":"20241031152812-wa3y758","Type":"NodeParagraph","Properties":{"id":"20241031152812-wa3y758","updated":"20241031152812"},"Children":[{"Type":"NodeText","Data":"写时复制技术使得在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 之后，如果父子进程没有修改大部分内存，系统就不需要为每个进程分配独立的物理内存页，从而大大节省了内存资源。此外，由于只有在实际写操作发生时才进行内存复制，操作系统的内存开销也被推迟到了真正需要的时候。"}]}]}]}]}]},{"ID":"20241031152813-49mvutr","Type":"NodeParagraph","Properties":{"id":"20241031152813-49mvutr","updated":"20241031152813"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"具体例子"}]},{"ID":"20241031152814-quja4jj","Type":"NodeParagraph","Properties":{"id":"20241031152814-quja4jj","updated":"20241031152814"},"Children":[{"Type":"NodeText","Data":"假设父进程有一个较大的数组 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int arr[10000]"},{"Type":"NodeText","Data":"，当 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 之后，如果子进程没有对这个数组进行修改，父子进程将共享这块内存区域。如果子进程尝试修改 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"arr[0]"},{"Type":"NodeText","Data":"，那么这块内存的页面会被复制，并且子进程获得一个独立的内存页来存储新的数据。"}]},{"ID":"20241031152815-5506uk0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152815-5506uk0","updated":"20241031152815"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cunistd.h\u003e\n#include \u003csys/wait.h\u003e\n\nint main() {\n    int arr[10000] = {0};  // 假设这是一个大数组\n    pid_t pid = fork();\n\n    if (pid == 0) { // 子进程\n        arr[0] = 1;  // 触发写时复制\n        std::cout \u003c\u003c \"Child process modified arr[0]: \" \u003c\u003c arr[0] \u003c\u003c std::endl;\n    } else { // 父进程\n        wait(NULL); // 等待子进程结束\n        std::cout \u003c\u003c \"Parent process arr[0]: \" \u003c\u003c arr[0] \u003c\u003c std::endl;\n    }\n    \n    return 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152816-c03lyqb","Type":"NodeParagraph","Properties":{"id":"20241031152816-c03lyqb","updated":"20241031152816"},"Children":[{"Type":"NodeText","Data":"在这个例子中，当子进程试图修改 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"arr[0]"},{"Type":"NodeText","Data":" 时，写时复制将导致这个页面被复制到一个新的物理地址上，并且子进程获得了该页的独立副本，之后父进程和子进程分别持有各自的内存页面。"}]},{"ID":"20241031152817-ott30ph","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241031152817-ott30ph","updated":"20241031152817"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"优点与局限性"}]},{"ID":"20241031152818-18dhmvn","Type":"NodeParagraph","Properties":{"id":"20241031152818-18dhmvn","updated":"20241031152818"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"优点"},{"Type":"NodeText","Data":"："}]},{"ID":"20241031152819-wy8hc4x","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152819-wy8hc4x","updated":"20241031152819"},"Children":[{"ID":"20241031152820-wxs2of2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152820-wxs2of2","updated":"20241031152820"},"Children":[{"ID":"20241031152821-xwehas4","Type":"NodeParagraph","Properties":{"id":"20241031152821-xwehas4","updated":"20241031152821"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"节省内存"},{"Type":"NodeText","Data":"：在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 之后，父子进程可以共享大部分的只读内存页，节省了系统资源。"}]}]},{"ID":"20241031152822-7tbi0p9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152822-7tbi0p9","updated":"20241031152822"},"Children":[{"ID":"20241031152823-9lexx3q","Type":"NodeParagraph","Properties":{"id":"20241031152823-9lexx3q","updated":"20241031152823"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"延迟复制"},{"Type":"NodeText","Data":"：只有在实际修改时才进行复制操作，减少了不必要的内存分配。"}]}]}]},{"ID":"20241031152824-tg7q6qt","Type":"NodeParagraph","Properties":{"id":"20241031152824-tg7q6qt","updated":"20241031152824"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"局限性"},{"Type":"NodeText","Data":"："}]},{"ID":"20241031152825-68pvse6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152825-68pvse6","updated":"20241031152825"},"Children":[{"ID":"20241031152826-hw1jcci","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152826-hw1jcci","updated":"20241031152826"},"Children":[{"ID":"20241031152827-97higj4","Type":"NodeParagraph","Properties":{"id":"20241031152827-97higj4","updated":"20241031152827"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"复杂性"},{"Type":"NodeText","Data":"：写时复制增加了内存管理的复杂性，操作系统需要维护共享页和独立页之间的关系。"}]}]},{"ID":"20241031152828-cbe628y","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152828-cbe628y","updated":"20241031152828"},"Children":[{"ID":"20241031152829-ct3y5pp","Type":"NodeParagraph","Properties":{"id":"20241031152829-ct3y5pp","updated":"20241031152829"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"性能开销"},{"Type":"NodeText","Data":"：在写时复制发生时，页面错误处理和实际的内存复制可能导致一定的性能开销，特别是在频繁写入的情况下。"}]}]}]},{"ID":"20241031152830-d4cdfoe","Type":"NodeParagraph","Properties":{"id":"20241031152830-d4cdfoe","updated":"20241031152830"},"Children":[{"Type":"NodeText","Data":"写时复制机制广泛用于现代操作系统中，因为它在许多实际场景中有效地提高了内存使用效率。"}]},{"ID":"20241031152831-4a66n23","Type":"NodeBlockquote","Properties":{"id":"20241031152831-4a66n23","updated":"20241031152831"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241031152832-mkpvu7b","Type":"NodeParagraph","Properties":{"id":"20241031152832-mkpvu7b","updated":"20241031152832"},"Children":[{"Type":"NodeText","Data":"那写时复制会导致子进程中变量的地址改变吗？"}]}]},{"ID":"20241031152833-ql4n86j","Type":"NodeParagraph","Properties":{"id":"20241031152833-ql4n86j","updated":"20241031152833"},"Children":[{"Type":"NodeText","Data":"写时复制（Copy-On-Write, COW）"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"不会导致子进程中变量的地址改变"},{"Type":"NodeText","Data":"。在 Linux 中，父进程和子进程在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 后拥有相同的逻辑地址空间，因此它们各自的变量地址（即逻辑地址）在内存中的位置是相同的。"}]},{"ID":"20241031152834-hojfuvt","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241031152834-hojfuvt","updated":"20241031152834"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"不会改变逻辑地址"}]},{"ID":"20241031152835-pujci9r","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152835-pujci9r","updated":"20241031152835"},"Children":[{"ID":"20241031152836-4pvgaz7","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152836-4pvgaz7","updated":"20241031152836"},"Children":[{"ID":"20241031152837-308bymd","Type":"NodeParagraph","Properties":{"id":"20241031152837-308bymd","updated":"20241031152837"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"逻辑地址空间不变"},{"Type":"NodeText","Data":"：写时复制只影响物理内存的分配，而不会改变进程的逻辑地址空间。换句话说，父进程和子进程在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":" 后，变量的逻辑地址是一样的，无论是否触发写时复制。"}]}]},{"ID":"20241031152838-ojrizqs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241031152838-ojrizqs","updated":"20241031152838"},"Children":[{"ID":"20241031152839-n3l86zh","Type":"NodeParagraph","Properties":{"id":"20241031152839-n3l86zh","updated":"20241031152839"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"物理地址变化"},{"Type":"NodeText","Data":"：在写时复制的机制下，当子进程试图写入一个共享的页面时，操作系统会为这个页面分配一个新的物理内存，并将子进程的页面表更新为指向新的物理地址。然而，这个更新是透明的，子进程中变量的逻辑地址不会因此改变。"}]}]}]},{"ID":"20241031152840-4mneo09","Type":"NodeParagraph","Properties":{"id":"20241031152840-4mneo09","updated":"20241031152840"},"Children":[{"Type":"NodeText","Data":"举例说明"}]},{"ID":"20241031152841-ltw8tdp","Type":"NodeParagraph","Properties":{"id":"20241031152841-ltw8tdp","updated":"20241031152841"},"Children":[{"Type":"NodeText","Data":"假设有一个变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int x"},{"Type":"NodeText","Data":"，在父进程和子进程中都存在。如果子进程对 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 进行修改，写时复制机制会使操作系统复制 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 所在的内存页并分配新的物理内存给子进程。尽管物理内存发生了变化，子进程中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 的地址（逻辑地址）依然保持不变。"}]},{"ID":"20241031152842-iyht47u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152842-iyht47u","updated":"20241031152842"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cunistd.h\u003e\n\nint main() {\n    int x = 42;\n    \n    pid_t pid = fork();\n\n    if (pid == 0) { // 子进程\n        std::cout \u003c\u003c \"Child process, x address: \" \u003c\u003c \u0026x \u003c\u003c std::endl;\n        x = 100; // 触发写时复制\n        std::cout \u003c\u003c \"Child process, x address after modification: \" \u003c\u003c \u0026x \u003c\u003c std::endl;\n    } else { // 父进程\n        std::cout \u003c\u003c \"Parent process, x address: \" \u003c\u003c \u0026x \u003c\u003c std::endl;\n    }\n    \n    return 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152843-flcfy5n","Type":"NodeParagraph","Properties":{"id":"20241031152843-flcfy5n","updated":"20241031152843"},"Children":[{"Type":"NodeText","Data":"在这个例子中，输出结果会显示父进程和子进程中变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 的地址是相同的，即使子进程修改了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 并触发了写时复制。这是因为变量 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":" 的逻辑地址在父子进程中没有变化。"}]},{"ID":"20241031152844-8y5f9mh","Type":"NodeParagraph","Properties":{"id":"20241031152844-8y5f9mh","updated":"20241031152844"},"Children":[{"Type":"NodeText","Data":"总结"}]},{"ID":"20241031152845-nma4qa6","Type":"NodeParagraph","Properties":{"id":"20241031152845-nma4qa6","updated":"20241031152845"},"Children":[{"Type":"NodeText","Data":"写时复制机制不会改变子进程中变量的地址。即使写时复制导致物理内存页面发生变化，子进程中变量的逻辑地址仍然与父进程保持一致。"}]},{"ID":"20241031152846-smpbpjo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152846-smpbpjo","updated":"20241031153334"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"三、fork()函数"}]},{"ID":"20241031152847-3a2885o","Type":"NodeParagraph","Properties":{"id":"20241031152847-3a2885o","updated":"20241031152847"},"Children":[{"Type":"NodeText","Data":"一个现有的进程可以调用fork()函数创建一个新的进程。"}]},{"ID":"20241031152848-yo0sbw8","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Yysr","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152848-yo0sbw8","updated":"20241031152848"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"pid_t fork(void);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152849-afana1o","Type":"NodeParagraph","Properties":{"id":"20241031152849-afana1o","updated":"20241031152849"},"Children":[{"Type":"NodeText","Data":"由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":"创建的新进程被称为子进程。子进是父进程的副本，父进程和子进程都从调用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":"之后的代码开始执行。"}]},{"ID":"20241031152850-jvepea7","Type":"NodeParagraph","Properties":{"id":"20241031152850-jvepea7","updated":"20241031152850"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":"函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是子进程的进程ID。"}]},{"ID":"20241031152851-qmvkxj9","Type":"NodeParagraph","Properties":{"id":"20241031152851-qmvkxj9","updated":"20241031152851"},"Children":[{"Type":"NodeText","Data":"子进程获得了父进程数据空间、堆和栈的副本（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意：子进程拥有的是副本，不是和父进程共享"},{"Type":"NodeText","Data":"）。"}]},{"ID":"20241031152852-hq0kmju","Type":"NodeParagraph","Properties":{"id":"20241031152852-hq0kmju","updated":"20241031152852"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":"之后，父进程和子进程的执行顺序是不确定的。"}]},{"ID":"20241031153334-chgqq8s","Type":"NodeParagraph","Properties":{"id":"20241031153334-chgqq8s","updated":"20241031153334"}}]}