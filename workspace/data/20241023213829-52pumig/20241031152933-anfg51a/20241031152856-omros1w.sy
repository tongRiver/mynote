{"ID":"20241031152856-omros1w","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241031152856-omros1w","title":"生产-消费者模型-多线程\u0026amp;多进程-Java","type":"doc","updated":"20241031152856"},"Children":[{"ID":"20241031152857-8i2qe2h","Type":"NodeBlockquote","Properties":{"id":"20241031152857-8i2qe2h","updated":"20241031152857"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241031152858-8xcx28v","Type":"NodeParagraph","Properties":{"id":"20241031152858-8xcx28v","updated":"20241031152858"},"Children":[{"Type":"NodeText","Data":"你能用Java代码实现一下生产-消费者模型吗？"}]}]},{"ID":"20241031152859-00giawk","Type":"NodeParagraph","Properties":{"id":"20241031152859-00giawk","updated":"20241031152859"},"Children":[{"Type":"NodeText","Data":"下面是一个使用Java多线程和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"/"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"机制实现的生产者-消费者模型。该模型中，生产者线程负责生产产品，消费者线程负责消费产品。为了同步生产者和消费者，我们使用了一个共享的缓冲区（一个阻塞队列），并使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"wait()"},{"Type":"NodeText","Data":"和"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"notify()"},{"Type":"NodeText","Data":"来管理线程间的通信。"}]},{"ID":"20241031152860-vh4gdpc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152860-vh4gdpc","updated":"20241031152860"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.util.LinkedList;\nimport java.util.Queue;\n\nclass Buffer {\n    private final int capacity;\n    private final Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e();\n\n    public Buffer(int capacity) {\n        this.capacity = capacity;\n    }\n\n    // 生产者将产品加入缓冲区\n    public synchronized void produce(int value) throws InterruptedException {\n        while (queue.size() == capacity) {\n            System.out.println(\"Buffer is full, producer waiting...\");\n            wait();  // 等待消费者消费\n        }\n        queue.add(value);\n        System.out.println(\"Produced: \" + value);\n        notifyAll();  // 通知消费者有新的产品\n    }\n\n    // 消费者从缓冲区消费产品\n    public synchronized int consume() throws InterruptedException {\n        while (queue.isEmpty()) {\n            System.out.println(\"Buffer is empty, consumer waiting...\");\n            wait();  // 等待生产者生产\n        }\n        int value = queue.poll();\n        System.out.println(\"Consumed: \" + value);\n        notifyAll();  // 通知生产者可以生产\n        return value;\n    }\n}\n\nclass Producer implements Runnable {\n    private final Buffer buffer;\n\n    public Producer(Buffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        int value = 0;\n        try {\n            while (true) {\n                buffer.produce(value++);\n                Thread.sleep(1000);  // 模拟生产时间\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n    private final Buffer buffer;\n\n    public Consumer(Buffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                buffer.consume();\n                Thread.sleep(1500);  // 模拟消费时间\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class ProducerConsumerExample {\n    public static void main(String[] args) {\n        Buffer buffer = new Buffer(5);  // 缓冲区容量为5\n\n        Thread producerThread = new Thread(new Producer(buffer));\n        Thread consumerThread = new Thread(new Consumer(buffer));\n\n        producerThread.start();\n        consumerThread.start();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152861-l6rt0i9","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152861-l6rt0i9","updated":"20241031152861"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码说明："}]},{"ID":"20241031152862-xlhj9lt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152862-xlhj9lt","updated":"20241031152862"},"Children":[{"ID":"20241031152863-pi2qqwi","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152863-pi2qqwi","updated":"20241031152863"},"Children":[{"ID":"20241031152864-ugsv1g6","Type":"NodeParagraph","Properties":{"id":"20241031152864-ugsv1g6","updated":"20241031152864"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Buffer"},{"Type":"NodeText","Data":" 类是一个共享的缓冲区，内部使用了一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Queue"},{"Type":"NodeText","Data":" 来存储生产者生产的产品。它有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"produce"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"consume"},{"Type":"NodeText","Data":" 方法，分别由生产者和消费者调用。"}]}]},{"ID":"20241031152865-2lvj5q4","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241031152865-2lvj5q4","updated":"20241031152865"},"Children":[{"ID":"20241031152866-mn8rwoq","Type":"NodeParagraph","Properties":{"id":"20241031152866-mn8rwoq","updated":"20241031152866"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"produce"},{"Type":"NodeText","Data":" 方法：如果缓冲区满了，生产者会等待，直到消费者消费后发出通知。"}]}]},{"ID":"20241031152867-zi7daru","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241031152867-zi7daru","updated":"20241031152867"},"Children":[{"ID":"20241031152868-7inxwfo","Type":"NodeParagraph","Properties":{"id":"20241031152868-7inxwfo","updated":"20241031152868"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"consume"},{"Type":"NodeText","Data":" 方法：如果缓冲区空了，消费者会等待，直到生产者生产后发出通知。"}]}]},{"ID":"20241031152869-2u8rhhn","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20241031152869-2u8rhhn","updated":"20241031152869"},"Children":[{"ID":"20241031152870-fhinbkw","Type":"NodeParagraph","Properties":{"id":"20241031152870-fhinbkw","updated":"20241031152870"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Producer"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Consumer"},{"Type":"NodeText","Data":" 类分别代表生产者和消费者，它们通过实现 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Runnable"},{"Type":"NodeText","Data":" 接口来运行在独立的线程中。"}]}]},{"ID":"20241031152871-eilfgv2","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20241031152871-eilfgv2","updated":"20241031152871"},"Children":[{"ID":"20241031152872-6dj75z9","Type":"NodeParagraph","Properties":{"id":"20241031152872-6dj75z9","updated":"20241031152872"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"main"},{"Type":"NodeText","Data":" 函数中，创建了一个容量为 5 的缓冲区，并启动了生产者和消费者线程。"}]}]}]},{"ID":"20241031152873-o1gp8f1","Type":"NodeParagraph","Properties":{"id":"20241031152873-o1gp8f1","updated":"20241031152873"},"Children":[{"Type":"NodeText","Data":"这样，生产者和消费者可以在同步的情况下运行，避免缓冲区过满或为空时出现问题。"}]},{"ID":"20241031152874-xm9ttf3","Type":"NodeBlockquote","Properties":{"id":"20241031152874-xm9ttf3","updated":"20241031152874"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241031152875-00lhh7b","Type":"NodeParagraph","Properties":{"id":"20241031152875-00lhh7b","updated":"20241031152875"},"Children":[{"Type":"NodeText","Data":"如果用多进程的方式该怎么实现呢？"}]}]},{"ID":"20241031152876-ilbfpcq","Type":"NodeParagraph","Properties":{"id":"20241031152876-ilbfpcq","updated":"20241031152876"},"Children":[{"Type":"NodeText","Data":"要用多进程的方式实现生产者-消费者模型，可以通过进程间通信机制来同步生产者和消费者的操作。在Java中，多进程通信可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent"},{"Type":"NodeText","Data":" 包中的工具类实现，比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 或使用低级别的管道、共享内存等。而在操作系统层面，使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ProcessBuilder"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PipedInputStream/PipedOutputStream"},{"Type":"NodeText","Data":" 也是一种方案。"}]},{"ID":"20241031152877-2p4ygjw","Type":"NodeParagraph","Properties":{"id":"20241031152877-2p4ygjw","updated":"20241031152877"},"Children":[{"Type":"NodeText","Data":"但因为Java在大多数场景中更倾向于多线程编程，而多进程模型更多见于操作系统原生接口如Linux下的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"fork()"},{"Type":"NodeText","Data":"，以下是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"java.util.concurrent.ArrayBlockingQueue"},{"Type":"NodeText","Data":" 来模拟多进程生产者-消费者模式的例子。为了更贴近多进程环境，生产者和消费者将通过独立的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Process"},{"Type":"NodeText","Data":" 启动，使用管道或消息队列进行进程间通信。"}]},{"ID":"20241031152878-1aw0nsq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152878-1aw0nsq","updated":"20241031152878"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"示例1：使用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"实现进程间通信"}]},{"ID":"20241031152879-4emwwxz","Type":"NodeParagraph","Properties":{"id":"20241031152879-4emwwxz","updated":"20241031152879"},"Children":[{"Type":"NodeText","Data":"在这个例子中，我们创建两个独立的进程，一个作为生产者，一个作为消费者，它们通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":" 进行通信。"}]},{"ID":"20241031152880-11iq9ke","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241031152880-11iq9ke","updated":"20241031152880"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"import java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\nclass Buffer {\n    private final BlockingQueue\u003cInteger\u003e queue;\n\n    public Buffer(int capacity) {\n        this.queue = new ArrayBlockingQueue\u003c\u003e(capacity);\n    }\n\n    // 生产者方法\n    public void produce(int value) throws InterruptedException {\n        queue.put(value);  // 使用BlockingQueue的阻塞特性\n        System.out.println(\"Produced: \" + value);\n    }\n\n    // 消费者方法\n    public int consume() throws InterruptedException {\n        int value = queue.take();  // 从队列中取出一个元素\n        System.out.println(\"Consumed: \" + value);\n        return value;\n    }\n}\n\nclass ProducerProcess extends Thread {\n    private final Buffer buffer;\n\n    public ProducerProcess(Buffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        int value = 0;\n        try {\n            while (true) {\n                buffer.produce(value++);\n                Thread.sleep(1000);  // 模拟生产时间\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\nclass ConsumerProcess extends Thread {\n    private final Buffer buffer;\n\n    public ConsumerProcess(Buffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                buffer.consume();\n                Thread.sleep(1500);  // 模拟消费时间\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n\npublic class ProducerConsumerMultiProcess {\n    public static void main(String[] args) throws InterruptedException {\n        Buffer buffer = new Buffer(5);  // 缓冲区容量为5\n\n        // 模拟独立的生产者和消费者进程\n        ProducerProcess producerProcess = new ProducerProcess(buffer);\n        ConsumerProcess consumerProcess = new ConsumerProcess(buffer);\n\n        // 启动生产者和消费者进程\n        producerProcess.start();\n        consumerProcess.start();\n\n        // 让主线程保持运行，等待进程完成\n        producerProcess.join();\n        consumerProcess.join();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241031152881-hezxxi0","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152881-hezxxi0","updated":"20241031152881"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"代码解释："}]},{"ID":"20241031152882-tvm1frt","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152882-tvm1frt","updated":"20241031152882"},"Children":[{"ID":"20241031152883-bcatqa2","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241031152883-bcatqa2","updated":"20241031152883"},"Children":[{"ID":"20241031152884-kymfnw2","Type":"NodeParagraph","Properties":{"id":"20241031152884-kymfnw2","updated":"20241031152884"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"BlockingQueue"},{"Type":"NodeText","Data":"："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ArrayBlockingQueue"},{"Type":"NodeText","Data":" 是一个线程安全的阻塞队列，它内部实现了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"put()"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"take()"},{"Type":"NodeText","Data":" 方法，分别用来向队列中添加元素和从队列中取出元素，生产者在队列满时会阻塞，消费者在队列为空时也会阻塞，避免资源竞争。"}]}]},{"ID":"20241031152885-e8lf12u","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241031152885-e8lf12u","updated":"20241031152885"},"Children":[{"ID":"20241031152886-6l4dkng","Type":"NodeParagraph","Properties":{"id":"20241031152886-6l4dkng","updated":"20241031152886"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"多进程模拟"},{"Type":"NodeText","Data":"：虽然我们使用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 创建了生产者和消费者线程，但在实际进程模型中，你可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ProcessBuilder"},{"Type":"NodeText","Data":" 或者其他跨进程通信方式（如管道、消息队列）实现独立进程间的通信。"}]}]},{"ID":"20241031152887-sc5rdxy","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241031152887-sc5rdxy","updated":"20241031152887"},"Children":[{"ID":"20241031152888-oucz3p4","Type":"NodeParagraph","Properties":{"id":"20241031152888-oucz3p4","updated":"20241031152888"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ProducerProcess"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ConsumerProcess"},{"Type":"NodeText","Data":"：分别作为独立的生产者和消费者进程启动。"}]}]}]},{"ID":"20241031152889-b12zpyc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152889-b12zpyc","updated":"20241031152889"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"示例2：使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ProcessBuilder"},{"Type":"NodeText","Data":" 创建多进程并通过管道通信"}]},{"ID":"20241031152890-i51yg1r","Type":"NodeParagraph","Properties":{"id":"20241031152890-i51yg1r","updated":"20241031152890"},"Children":[{"Type":"NodeText","Data":"如果你希望严格使用多进程通信，可以考虑使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ProcessBuilder"},{"Type":"NodeText","Data":" 启动多个独立的 Java 程序，并使用标准输入输出或者 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PipedInputStream"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"PipedOutputStream"},{"Type":"NodeText","Data":" 进行通信。由于Java中的多进程编程不如多线程常用，实际操作系统中更推荐通过消息队列、共享内存等实现进程间通信。"}]},{"ID":"20241031152891-mnnxwkc","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241031152891-mnnxwkc","updated":"20241031152891"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结："}]},{"ID":"20241031152892-pwylv99","Type":"NodeParagraph","Properties":{"id":"20241031152892-pwylv99","updated":"20241031152892"},"Children":[{"Type":"NodeText","Data":"Java的多进程编程主要通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ProcessBuilder"},{"Type":"NodeText","Data":" 创建子进程，但生产-消费者模型通常在Java中通过多线程实现。多进程模型在操作系统层面会涉及到更多的资源隔离和通信机制，例如管道、共享内存等。如果你对多进程模型感兴趣，可能需要结合操作系统层的特性去实现。"}]}]}