{"ID":"20241015202831-p0dww65","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241015202831-p0dww65","title":"ThreadLocal存储用户信息","type":"doc","updated":"20241018154152"},"Children":[{"ID":"20241015202832-7j1mfpi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015202832-7j1mfpi","updated":"20241015202845"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"简单介绍"}]},{"ID":"20241015202833-2xazt7m","Type":"NodeBlockquote","Properties":{"id":"20241015202833-2xazt7m","updated":"20241015202833"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015202834-u7m1rlw","Type":"NodeParagraph","Properties":{"id":"20241015202834-u7m1rlw","updated":"20241015202834"},"Children":[{"Type":"NodeText","Data":"你知道Springboot中的ThreadLocal吗？"}]}]},{"ID":"20241015202835-qkkf46m","Type":"NodeParagraph","Properties":{"id":"20241015202835-qkkf46m","updated":"20241015202835"},"Children":[{"Type":"NodeText","Data":"是的，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 是 Java 中的一个工具类，在 Spring Boot 中也常常被使用。"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 提供了线程本地变量，这意味着每个线程都有自己独立的变量副本，其他线程无法访问或修改。这对于线程安全非常有用，因为它避免了多个线程之间共享变量导致的数据不一致问题。"}]},{"ID":"20241015202836-2njyrt5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202836-2njyrt5","updated":"20241015202845"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的使用场景："}]},{"ID":"20241015202837-aqv0x9c","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015202837-aqv0x9c","updated":"20241015202845"},"Children":[{"ID":"20241015202838-x68lusj","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015202838-x68lusj","updated":"20241015202838"},"Children":[{"ID":"20241015202839-t2qf3kw","Type":"NodeParagraph","Properties":{"id":"20241015202839-t2qf3kw","updated":"20241015202839"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"线程安全"},{"Type":"NodeText","Data":"：避免线程间共享变量引起的数据竞争问题。"}]}]},{"ID":"20241015202840-v0px335","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015202840-v0px335","updated":"20241015202840"},"Children":[{"ID":"20241015202841-cf5nh7h","Type":"NodeParagraph","Properties":{"id":"20241015202841-cf5nh7h","updated":"20241015202841"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"数据隔离"},{"Type":"NodeText","Data":"：每个线程有自己的一份数据，不会互相干扰。"}]}]},{"ID":"20241015202842-wviu55r","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241015202842-wviu55r","updated":"20241015202842"},"Children":[{"ID":"20241015202843-vv2cjhg","Type":"NodeParagraph","Properties":{"id":"20241015202843-vv2cjhg","updated":"20241015202843"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"事务管理"},{"Type":"NodeText","Data":"：在 Spring 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 常用于存储当前线程的事务信息。"}]}]},{"ID":"20241015202844-1zvrhl7","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20241015202844-1zvrhl7","updated":"20241015202845"},"Children":[{"ID":"20241015202845-p0b84ir","Type":"NodeParagraph","Properties":{"id":"20241015202845-p0b84ir","updated":"20241015202845"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"用户会话管理"},{"Type":"NodeText","Data":"：可以用来存储每个请求的用户信息，从而实现简单的上下文管理。"}]}]}]},{"ID":"20241015202846-foj2w7u","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202846-foj2w7u","updated":"20241015202848"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的常见使用方式："}]},{"ID":"20241015202847-vr6q7j0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015202847-vr6q7j0","updated":"20241015202847"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class UserContext {\n    private static final ThreadLocal\u003cString\u003e userHolder = new ThreadLocal\u003c\u003e();\n\n    public static void setUser(String user) {\n        userHolder.set(user);\n    }\n\n    public static String getUser() {\n        return userHolder.get();\n    }\n\n    public static void clear() {\n        userHolder.remove();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015202848-qx9skrx","Type":"NodeParagraph","Properties":{"id":"20241015202848-qx9skrx","updated":"20241015202848"},"Children":[{"Type":"NodeText","Data":"在上述例子中，我们创建了一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"UserContext"},{"Type":"NodeText","Data":"​ 类，它使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"​ 来存储当前线程的用户信息。"}]},{"ID":"20241015202849-mcjza5f","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202849-mcjza5f","updated":"20241015202858"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"注意事项："}]},{"ID":"20241015202850-as9nd4p","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202850-as9nd4p","updated":"20241015202850"},"Children":[{"ID":"20241015202851-b8hooy9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202851-b8hooy9","updated":"20241015202851"},"Children":[{"ID":"20241015202852-f395gwk","Type":"NodeParagraph","Properties":{"id":"20241015202852-f395gwk","updated":"20241015202852"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"内存泄漏"},{"Type":"NodeText","Data":"：由于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量会与线程生命周期关联，如果没有及时清理（例如调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":" 方法），可能会导致内存泄漏。"}]}]},{"ID":"20241015202853-26e4ypm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202853-26e4ypm","updated":"20241015202853"},"Children":[{"ID":"20241015202854-0eg319w","Type":"NodeParagraph","Properties":{"id":"20241015202854-0eg319w","updated":"20241015202854"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"资源清理"},{"Type":"NodeText","Data":"：在完成线程任务时，务必要清理 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 中的变量，避免不必要的资源占用。"}]}]}]},{"ID":"20241015202855-gx6rs1a","Type":"NodeParagraph","Properties":{"id":"20241015202855-gx6rs1a","updated":"20241015202855"},"Children":[{"Type":"NodeText","Data":"在 Spring Boot 中，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"​ 常与拦截器、过滤器或者 AOP 配合使用，以在请求的不同阶段存储和传递数据。如果你有具体的使用场景或问题，可以进一步探讨！"}]},{"ID":"20241015203132-75piqn6","Type":"NodeParagraph","Properties":{"id":"20241015203132-75piqn6","updated":"20241015203132"}},{"ID":"20241015202856-6dc3njc","Type":"NodeBlockquote","Properties":{"id":"20241015202856-6dc3njc","updated":"20241015202856"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015202857-yqhmf4t","Type":"NodeParagraph","Properties":{"id":"20241015202857-yqhmf4t","updated":"20241015202857"},"Children":[{"Type":"NodeText","Data":"那么不同的线程调用ThreadLocal进行set，存储的数据就不一样吗？不同的线程使用ThreadLocal进行get，得到的数据也不一样吗？"}]}]},{"ID":"20241015202858-x7t6bpx","Type":"NodeParagraph","Properties":{"id":"20241015202858-x7t6bpx","updated":"20241015202858"},"Children":[{"Type":"NodeText","Data":"是的，不同的线程调用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"​ 进行 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"set"},{"Type":"NodeText","Data":"​ 操作时，存储的数据是彼此独立的。每个线程有自己的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"​ 变量副本，因此它们之间是互不干扰的。"}]},{"ID":"20241015202859-x6krb35","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202859-x6krb35","updated":"20241015203152"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"详细说明："}]},{"ID":"20241015202860-79xiun1","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015202860-79xiun1","updated":"20241015202860"},"Children":[{"ID":"20241015202861-yuc48df","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015202861-yuc48df","updated":"20241015202861"},"Children":[{"ID":"20241015202862-1wvnbjf","Type":"NodeParagraph","Properties":{"id":"20241015202862-1wvnbjf","updated":"20241015202862"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal.set()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 操作"},{"Type":"NodeText","Data":"：当一个线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"set()"},{"Type":"NodeText","Data":" 方法时，它实际上是在该线程自己的副本上存储数据，而不是在所有线程间共享。因此，不同的线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal.set()"},{"Type":"NodeText","Data":" 时，即使是同一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象，也会存储不同的数据。例如："}]},{"ID":"20241015202863-aq6m947","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015202863-aq6m947","updated":"20241015202863"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ThreadLocal\u003cString\u003e threadLocal = new ThreadLocal\u003c\u003e();\n\nThread thread1 = new Thread(() -\u003e {\n    threadLocal.set(\"Thread 1 data\");\n    System.out.println(\"Thread 1: \" + threadLocal.get());\n});\n\nThread thread2 = new Thread(() -\u003e {\n    threadLocal.set(\"Thread 2 data\");\n    System.out.println(\"Thread 2: \" + threadLocal.get());\n});\n\nthread1.start();\nthread2.start();\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015202864-alzt3dt","Type":"NodeParagraph","Properties":{"id":"20241015202864-alzt3dt","updated":"20241015202864"},"Children":[{"Type":"NodeText","Data":"以上代码中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"thread1"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"thread2"},{"Type":"NodeText","Data":" 各自调用了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"threadLocal.set()"},{"Type":"NodeText","Data":" 方法来存储数据。它们会打印出不同的结果，因为每个线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 副本是独立的。"}]}]},{"ID":"20241015202865-8zfvlh0","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015202865-8zfvlh0","updated":"20241015202865"},"Children":[{"ID":"20241015202866-26v0i8z","Type":"NodeParagraph","Properties":{"id":"20241015202866-26v0i8z","updated":"20241015202866"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal.get()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 操作"},{"Type":"NodeText","Data":"：当一个线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"get()"},{"Type":"NodeText","Data":" 方法时，它获取的也是该线程自己副本的数据。每个线程只能访问自己通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal.set()"},{"Type":"NodeText","Data":" 存储的数据，不能访问其他线程存储的数据。因此，不同的线程使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal.get()"},{"Type":"NodeText","Data":" 得到的数据是不一样的。"}]}]}]},{"ID":"20241015202867-9nwlktt","Type":"NodeParagraph","Properties":{"id":"20241015202867-9nwlktt","updated":"20241015202867"},"Children":[{"Type":"NodeText","Data":"总结来说，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"​ 允许线程在不与其他线程共享的情况下存储和访问数据，每个线程都有自己的独立副本。这种设计非常适合需要线程隔离的场景，尤其是在多线程环境下的安全性和性能优化。"}]},{"ID":"20241015203152-d559xcj","Type":"NodeParagraph","Properties":{"id":"20241015203152-d559xcj","updated":"20241015203152"}},{"ID":"20241015202868-kk91tqh","Type":"NodeBlockquote","Properties":{"id":"20241015202868-kk91tqh","updated":"20241015202868"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015202869-9bwe1ix","Type":"NodeParagraph","Properties":{"id":"20241015202869-9bwe1ix","updated":"20241015202869"},"Children":[{"Type":"NodeText","Data":"那么ThreadLocal是如何做到这一点的呢？"}]}]},{"ID":"20241015202870-xcdf0mc","Type":"NodeParagraph","Properties":{"id":"20241015202870-xcdf0mc","updated":"20241015202870"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":"​ 能够让每个线程拥有自己独立的变量副本，这是通过 Java 中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"​ 的机制实现的。下面我来详细解释其工作原理。"}]},{"ID":"20241015202871-zyeb3vw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202871-zyeb3vw","updated":"20241015202871"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的工作机制"}]},{"ID":"20241015202872-nw8137l","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015202872-nw8137l","updated":"20241015202872"},"Children":[{"ID":"20241015202873-gqr92dt","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015202873-gqr92dt","updated":"20241015202873"},"Children":[{"ID":"20241015202874-ikbz39j","Type":"NodeParagraph","Properties":{"id":"20241015202874-ikbz39j","updated":"20241015202874"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"每个线程有自己的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"每个 Java 线程内部都有一个叫做 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 的数据结构，它是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 类专门设计的存储区域。这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 是存储在线程内部的，也就是说每个线程有自己独立的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"，不会和其他线程共享。"}]},{"ID":"20241015202875-ey8xew8","Type":"NodeParagraph","Properties":{"id":"20241015202875-ey8xew8","updated":"20241015202875"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Thread"},{"Type":"NodeText","Data":" 类中，有一个成员变量："}]},{"ID":"20241015202876-hq8ed63","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015202876-hq8ed63","updated":"20241015202876"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */\nThreadLocal.ThreadLocalMap threadLocals = null;\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015202877-7g9dg6v","Type":"NodeParagraph","Properties":{"id":"20241015202877-7g9dg6v","updated":"20241015202877"},"Children":[{"Type":"NodeText","Data":"这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"threadLocals"},{"Type":"NodeText","Data":" 用来存储与该线程相关的所有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量。"}]}]},{"ID":"20241015202878-xlboxrc","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015202878-xlboxrc","updated":"20241015202878"},"Children":[{"ID":"20241015202879-ymbmqwp","Type":"NodeParagraph","Properties":{"id":"20241015202879-ymbmqwp","updated":"20241015202879"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 结构"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 本质上是一个哈希表，其中每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象作为键，它所存储的值作为相应的值。也就是说，每个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中都有一个条目，存储该线程在这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 中设置的值。"}]}]},{"ID":"20241015202880-1icr4ed","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241015202880-1icr4ed","updated":"20241015202880"},"Children":[{"ID":"20241015202881-3w46xjy","Type":"NodeParagraph","Properties":{"id":"20241015202881-3w46xjy","updated":"20241015202881"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal.set()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 过程"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当一个线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal.set()"},{"Type":"NodeText","Data":" 方法时，实际上是将数据存储在当前线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中。具体过程如下："}]},{"ID":"20241015202882-p8urh1d","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202882-p8urh1d","updated":"20241015202882"},"Children":[{"ID":"20241015202883-3uj20ty","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202883-3uj20ty","updated":"20241015202883"},"Children":[{"ID":"20241015202884-dtoc8rh","Type":"NodeParagraph","Properties":{"id":"20241015202884-dtoc8rh","updated":"20241015202884"},"Children":[{"Type":"NodeText","Data":"首先，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象会通过当前线程获取这个线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20241015202885-bxy75g9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202885-bxy75g9","updated":"20241015202885"},"Children":[{"ID":"20241015202886-z2vxb4m","Type":"NodeParagraph","Properties":{"id":"20241015202886-z2vxb4m","updated":"20241015202886"},"Children":[{"Type":"NodeText","Data":"然后，它会以自己作为键，把对应的数据存储到这个线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中。"}]}]}]},{"ID":"20241015202887-ats9nvm","Type":"NodeParagraph","Properties":{"id":"20241015202887-ats9nvm","updated":"20241015202887"},"Children":[{"Type":"NodeText","Data":"伪代码："}]},{"ID":"20241015202888-qg2x9cq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015202888-qg2x9cq","updated":"20241015202888"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ThreadLocalMap map = getMapForCurrentThread();  // 获取当前线程的 ThreadLocalMap\nmap.put(this, value);  // 使用 ThreadLocal 对象作为键存储数据\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20241015202889-xitintd","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20241015202889-xitintd","updated":"20241015202889"},"Children":[{"ID":"20241015202890-wxvkyj9","Type":"NodeParagraph","Properties":{"id":"20241015202890-wxvkyj9","updated":"20241015202890"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"ThreadLocal.get()"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 过程"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"当一个线程调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal.get()"},{"Type":"NodeText","Data":" 方法时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 会通过当前线程获取到这个线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"，然后通过当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象作为键去查找对应的值。具体过程如下："}]},{"ID":"20241015202891-ax3kv7h","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202891-ax3kv7h","updated":"20241015202891"},"Children":[{"ID":"20241015202892-0wocyig","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202892-0wocyig","updated":"20241015202892"},"Children":[{"ID":"20241015202893-4y2c7e5","Type":"NodeParagraph","Properties":{"id":"20241015202893-4y2c7e5","updated":"20241015202893"},"Children":[{"Type":"NodeText","Data":"从当前线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中找到与当前 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量相关的值，并返回。"}]}]}]},{"ID":"20241015202894-0uj6ht1","Type":"NodeParagraph","Properties":{"id":"20241015202894-0uj6ht1","updated":"20241015202894"},"Children":[{"Type":"NodeText","Data":"伪代码："}]},{"ID":"20241015202895-bn6eouz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015202895-bn6eouz","updated":"20241015202895"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ThreadLocalMap map = getMapForCurrentThread();  // 获取当前线程的 ThreadLocalMap\nvalue = map.get(this);  // 通过 ThreadLocal 对象作为键获取对应的值\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20241015202896-orm32ak","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20241015202896-orm32ak","updated":"20241015202896"},"Children":[{"ID":"20241015202897-eqog97g","Type":"NodeParagraph","Properties":{"id":"20241015202897-eqog97g","updated":"20241015202897"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么线程之间不会互相影响"},{"Type":"NodeText","Data":"："},{"Type":"NodeSoftBreak","Data":"\n","Properties":{"id":""}},{"Type":"NodeText","Data":"由于每个线程都有自己独立的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"，所以即便不同的线程操作同一个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象，它们实际存储的数据是在各自的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中，因此线程间不会相互干扰。这也是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 能够实现线程隔离的根本原因。"}]}]}]},{"ID":"20241015202898-2vczkvz","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202898-2vczkvz","updated":"20241015202898"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的生命周期管理"}]},{"ID":"20241015202899-276h2sd","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202899-276h2sd","updated":"20241015202899"},"Children":[{"ID":"20241015202900-vffo1rn","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202900-vffo1rn","updated":"20241015202900"},"Children":[{"ID":"20241015202901-z68jmwi","Type":"NodeParagraph","Properties":{"id":"20241015202901-z68jmwi","updated":"20241015202901"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 的生命周期与线程的生命周期绑定。当线程结束时，线程的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 也会被垃圾回收，因此对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量也会被清理。"}]}]},{"ID":"20241015202902-g1qnpze","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015202902-g1qnpze","updated":"20241015202902"},"Children":[{"ID":"20241015202903-k2xgeej","Type":"NodeParagraph","Properties":{"id":"20241015202903-k2xgeej","updated":"20241015202903"},"Children":[{"Type":"NodeText","Data":"如果 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 在使用完后没有调用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"remove()"},{"Type":"NodeText","Data":"，可能会出现内存泄漏问题，尤其是在使用线程池的情况下。因为线程池中的线程可能会被复用，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 变量如果没有清理，旧的值可能会被保留在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 中，从而导致内存泄漏或数据污染。"}]}]}]},{"ID":"20241015202904-0puo5jv","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015202904-0puo5jv","updated":"20241015203200"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20241015202905-85rscu1","Type":"NodeParagraph","Properties":{"id":"20241015202905-85rscu1","updated":"20241015202905"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 之所以能做到每个线程拥有独立的数据，是因为每个线程都有自己专属的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"，而这个 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":" 以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocal"},{"Type":"NodeText","Data":" 对象为键来存储数据。每个线程只会访问自己线程内的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ThreadLocalMap"},{"Type":"NodeText","Data":"，因此不会影响其他线程的数据。"}]},{"ID":"20241015203200-l6qlltd","Type":"NodeParagraph","Properties":{"id":"20241015203200-l6qlltd","updated":"20241015203200"}},{"ID":"20241015202906-4b7rymi","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015202906-4b7rymi","updated":"20241018154152"},"Children":[{"Type":"NodeText","Data":"登录认证中使用（黑马）"}]},{"ID":"20241015202907-36x6npa","Type":"NodeBlockquote","Properties":{"id":"20241015202907-36x6npa","updated":"20241015202907"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015202908-bif2pw2","Type":"NodeParagraph","Properties":{"id":"20241015202908-bif2pw2","updated":"20241015202908"},"Children":[{"Type":"NodeText","Data":"【黑马程序员SpringBoot3+Vue3全套视频教程，springboot+vue企业级全栈开发从基础、实战到面试一套通关】 https://www.bilibili.com/video/BV14z4y1N7pg/?p=22\u0026share_source=copy_web\u0026vd_source=29909144aff7d2c1451e8d294e9a5437"}]}]},{"ID":"20241018152131-bbj0qqz","Type":"NodeParagraph","Properties":{"id":"20241018152131-bbj0qqz","updated":"20241018152151"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"登录/ThreadLocal"},{"Type":"NodeText","Data":"​"}]},{"ID":"20241015202909-ixxxaio","Type":"NodeParagraph","Properties":{"id":"20241015202909-ixxxaio","updated":"20241015202909"},"Children":[{"Type":"NodeText","Data":"首先JWT是用来验证用户的，在interceptor中解析JWT，能解析成功就放行，否则返回。"}]},{"ID":"20241015202910-p7v3z1p","Type":"NodeParagraph","Properties":{"id":"20241015202910-p7v3z1p","updated":"20241015202910"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"image-20240922211348793","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/image-20240922211348793-20241015203011-p594myj.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20241015202911-pp0al93","Type":"NodeParagraph","Properties":{"id":"20241015202911-pp0al93","updated":"20241015202911"},"Children":[{"Type":"NodeText","Data":"但是在每个controller中，我都需要用户的id怎么办？麻烦的方法是在每个controller中都直接从请求头中拿JWT，然后在每个controller中都解析一遍，解析出来就可以用了，但是代码重复。"}]},{"ID":"20241015202912-m297284","Type":"NodeParagraph","Properties":{"id":"20241015202912-m297284","updated":"20241015202912"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"image-20240922211616582","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/image-20240922211616582-20241015203011-ucwmgh5.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20241015202913-yvonsal","Type":"NodeParagraph","Properties":{"id":"20241015202913-yvonsal","updated":"20241015202913"},"Children":[{"Type":"NodeText","Data":"因此我们的方法是，既然在拦截器中已经解析了，那么就把解析的结果存起来，后面想用的时候直接拿出来。存在ThreadLocal中。每个线程往ThreadLocal中存不同的数据，get到的都是自己的数据，不会干扰其他线程。"}]},{"ID":"20241015202914-1rvlaom","Type":"NodeParagraph","Properties":{"id":"20241015202914-1rvlaom","updated":"20241015202914"},"Children":[{"Type":"NodeText","Data":"而Tomcat正好给每个用户都开一个线程，因此我们可以在同一个线程执行的代码间共享数据了。"}]},{"ID":"20241015202915-l9kxwt5","Type":"NodeParagraph","Properties":{"id":"20241015202915-l9kxwt5","updated":"20241015202915"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"image-20240922211835197","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/image-20240922211835197-20241015203011-m7xsmdt.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20241015202916-iorfwen","Type":"NodeParagraph","Properties":{"id":"20241015202916-iorfwen","updated":"20241015202916"},"Children":[{"Type":"NodeText","Data":"具体实现："}]},{"ID":"20241015202917-gt1c4ni","Type":"NodeList","ListData":{},"Properties":{"id":"20241015202917-gt1c4ni","updated":"20241018154152"},"Children":[{"ID":"20241015202918-h8xjmay","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241015202918-h8xjmay","updated":"20241015202918"},"Children":[{"ID":"20241015202919-9ay7c7g","Type":"NodeParagraph","Properties":{"id":"20241015202919-9ay7c7g","updated":"20241015202919"},"Children":[{"Type":"NodeText","Data":"定义ThreadLocal工具类"}]},{"ID":"20241015202920-jmokp4b","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241015202920-jmokp4b","updated":"20241015202920"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"package com.myGroup.utils;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * ThreadLocal 工具类\n */\n@SuppressWarnings(\"all\")\npublic class ThreadLocalUtil {\n    //提供ThreadLocal对象,\n    private static final ThreadLocal THREAD_LOCAL = new ThreadLocal();\n\n    //根据键获取值\n    public static \u003cT\u003e T get(){\n        return (T) THREAD_LOCAL.get();\n    }\n\n    //存储键值对\n    public static void set(Object value){\n        THREAD_LOCAL.set(value);\n    }\n\n\n    //清除ThreadLocal 防止内存泄漏\n    public static void remove(){\n        THREAD_LOCAL.remove();\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241015202921-2zcjjyo","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241015202921-2zcjjyo","updated":"20241018154152"},"Children":[{"ID":"20241015202922-dgezd2r","Type":"NodeParagraph","Properties":{"id":"20241015202922-dgezd2r","updated":"20241015202922"},"Children":[{"Type":"NodeText","Data":"定义拦截器"}]},{"ID":"20241015202923-2hmv4se","Type":"NodeParagraph","Properties":{"id":"20241015202923-2hmv4se","updated":"20241015202923"},"Children":[{"Type":"NodeText","Data":"实现HandlerInterceptor接口，重写prehandle方法，拿到JWT之后解析，把结果通过ThreadLocalUtil.set放进去"}]},{"ID":"20241015202924-c427ojm","Type":"NodeParagraph","Properties":{"id":"20241015202924-c427ojm","updated":"20241015202924"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20240922212504249"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240922212504249-20241015203011-wwlhrcp.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20241018153921-yciwbz0","Type":"NodeParagraph","Properties":{"id":"20241018153921-yciwbz0","updated":"20241018153945"},"Children":[{"Type":"NodeText","Data":"LoginInterceptor的完整代码："}]},{"ID":"20241018153945-z6b945v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241018153945-z6b945v","updated":"20241018154152"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"@Component\n@Slf4j\npublic class LoginCheckInterceptor implements HandlerInterceptor {\n    /**\n     * 前置方法\n     *\n     * @param request\n     * @param response\n     * @param handler\n     * @return\n     * @throws Exception\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        //1.获取请求url\n        //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行\n        // PS：这两个可以不写，因为在注册自定义拦截器对象时我们允许login直接放行\n\n        //3.获取请求头中的令牌（token）\n        String token = request.getHeader(\"token\");\n        log.info(\"从请求头中获取的令牌：{}\", token);\n\n        // token 不存在\n        if (!StringUtils.hasLength(token)) {\n            log.info(\"Token不存在\");\n\n            //创建响应结果对象\n            R\u003cString\u003e responseResult = R.error(\"NOT_LOGIN\");\n            //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)\n            String json = JSONObject.toJSONString(responseResult);\n            //设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）\n            response.setContentType(\"application/json;charset=utf-8\");\n            //响应\n            response.getWriter().write(json);\n\n            return false;//不放行\n        }\n\n        //5.解析token，如果解析失败，返回错误结果（未登录）\n        try {\n            Map\u003cString, Object\u003e claims = JwtUtils.parseJWT(token);\n            log.info(\"从请求头中获取的令牌：{}\", claims);\n            // 【存到 ThreadLocal 中去】\n            ThreadLocalUtil.set(claims);\n        } catch (Exception e) {\n            log.info(\"令牌解析失败!\");\n\n            //创建响应结果对象\n            R\u003cString\u003e responseResult = R.error(\"NOT_LOGIN\");\n            //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类)\n            String json = JSONObject.toJSONString(responseResult);\n            //设置响应头\n            response.setContentType(\"application/json;charset=utf-8\");\n            //响应\n            response.getWriter().write(json);\n\n            return false;\n        }\n\n        //6.放行\n        return true;\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n        // 后处理：要记得删除ThreadLocal中的数据\n\t\tThreadLocalUtil.remove();\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]},{"ID":"20241015202925-xufwkof","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241015202925-xufwkof","updated":"20241015202925"},"Children":[{"ID":"20241015202926-6zm0axd","Type":"NodeParagraph","Properties":{"id":"20241015202926-6zm0axd","updated":"20241015202926"},"Children":[{"Type":"NodeText","Data":"在其他地方直接用，通过ThreadLocalUtil.get"}]},{"ID":"20241015202927-ljcqkuw","Type":"NodeParagraph","Properties":{"id":"20241015202927-ljcqkuw","updated":"20241015202927"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"image-20240922212613469"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/image-20240922212613469-20241015203011-22dhkx1.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]}]},{"ID":"20241015202928-swhfuwz","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20241015202928-swhfuwz","updated":"20241015202928"},"Children":[{"ID":"20241015202929-5xqvf4v","Type":"NodeParagraph","Properties":{"id":"20241015202929-5xqvf4v","updated":"20241015202929"},"Children":[{"Type":"NodeText","Data":"重写拦截器中的afterCompletion方法，清除掉JWT，防止内存泄漏"}]},{"ID":"20241015202930-izts1f7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20241015202930-izts1f7","updated":"20241015202930"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"@Override\npublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {\n    ThreadLocalUtil.remove();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}]},{"ID":"20241015203219-2kwj90w","Type":"NodeParagraph","Properties":{"id":"20241015203219-2kwj90w","updated":"20241015203219"}}]}