{"ID":"20241015203752-en5r2ez","Spec":"1","Type":"NodeDocument","Properties":{"id":"20241015203752-en5r2ez","title":"Java基础","type":"doc","updated":"20241015204603"},"Children":[{"ID":"20241015203753-j2bd0sw","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015203753-j2bd0sw","updated":"20241015203753"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"基础概念"}]},{"ID":"20241015203754-rp6ka2l","Type":"NodeParagraph","Properties":{"id":"20241015203754-rp6ka2l","updated":"20241015203754"},"Children":[{"Type":"NodeText","Data":"🌈 拓展一下："}]},{"ID":"20241015203755-mwwrh59","Type":"NodeParagraph","Properties":{"id":"20241015203755-mwwrh59","updated":"20241015203755"},"Children":[{"Type":"NodeText","Data":"“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你通过 Docker 就很容易实现跨平台了。在我看来，Java 强大的生态才是！"}]},{"ID":"20241015203756-3q15hmw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203756-3q15hmw","updated":"20241015203756"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#java-se-vs-java-ee","TextMarkTextContent":"Java SE vs Java EE"}]},{"ID":"20241015203757-njiveqx","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203757-njiveqx","updated":"20241015203757"},"Children":[{"ID":"20241015203758-bpyod3q","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203758-bpyod3q","updated":"20241015203758"},"Children":[{"ID":"20241015203759-kp2kko3","Type":"NodeParagraph","Properties":{"id":"20241015203759-kp2kko3","updated":"20241015203759"},"Children":[{"Type":"NodeText","Data":"Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。"}]}]},{"ID":"20241015203760-eu1v0e1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203760-eu1v0e1","updated":"20241015203760"},"Children":[{"ID":"20241015203761-iehtgjk","Type":"NodeParagraph","Properties":{"id":"20241015203761-iehtgjk","updated":"20241015203761"},"Children":[{"Type":"NodeText","Data":"Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。"}]}]}]},{"ID":"20241015203762-8aywgu3","Type":"NodeParagraph","Properties":{"id":"20241015203762-8aywgu3","updated":"20241015203762"},"Children":[{"Type":"NodeText","Data":"简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。"}]},{"ID":"20241015203763-2ge3dzg","Type":"NodeParagraph","Properties":{"id":"20241015203763-2ge3dzg","updated":"20241015203763"},"Children":[{"Type":"NodeText","Data":"除了 Java SE 和 Java EE，还有一个 Java ME（Java Platform，Micro Edition）。Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。Java ME 无需重点关注，知道有这个东西就好了，现在已经用不上了。"}]},{"ID":"20241015203764-lpfbqrs","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203764-lpfbqrs","updated":"20241015203764"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm-vs-jdk-vs-jre","TextMarkTextContent":"JVM vs JDK vs JRE"}]},{"ID":"20241015203765-ruz0baw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241015203765-ruz0baw","updated":"20241015203765"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm","TextMarkTextContent":"JVM"}]},{"ID":"20241015203766-hoina8w","Type":"NodeParagraph","Properties":{"id":"20241015203766-hoina8w","updated":"20241015203766"},"Children":[{"Type":"NodeText","Data":"Java 虚拟机（Java Virtual Machine, JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。"}]},{"ID":"20241015203767-l4emq5y","Type":"NodeParagraph","Properties":{"id":"20241015203767-l4emq5y","updated":"20241015203767"},"Children":[{"Type":"NodeText","Data":"如下图所示，不同编程语言（Java、Groovy、Kotlin、JRuby、Clojure ...）通过各自的编译器编译成 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件，并最终通过 JVM 在不同平台（Windows、Mac、Linux）上运行。"}]},{"ID":"20241015203768-dvhv5cu","Type":"NodeParagraph","Properties":{"id":"20241015203768-dvhv5cu","updated":"20241015203768"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"运行在 Java 虚拟机之上的编程语言","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/java-virtual-machine-program-language-os-20241015204334-ifqkv9t.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"运行在 Java 虚拟机之上的编程语言"}]},{"ID":"20241015203769-e0456ru","Type":"NodeParagraph","Properties":{"id":"20241015203769-e0456ru","updated":"20241015203769"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。"},{"Type":"NodeText","Data":" 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。"}]},{"ID":"20241015203770-gqe6n2a","Type":"NodeParagraph","Properties":{"id":"20241015203770-gqe6n2a","updated":"20241015203770"},"Children":[{"Type":"NodeText","Data":"除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines","TextMarkTextContent":"Comparison of Java virtual machinesopen in new window"},{"Type":"NodeText","Data":" ，感兴趣的可以去看看。并且，你可以在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://docs.oracle.com/javase/specs/index.html","TextMarkTextContent":"Java SE Specificationsopen in new window"},{"Type":"NodeText","Data":" 上找到各个版本的 JDK 对应的 JVM 规范。"}]},{"ID":"20241015203771-zsh6byw","Type":"NodeParagraph","Properties":{"id":"20241015203771-zsh6byw","updated":"20241015203771"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"img","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/JavaSeSpecifications-20241015204334-23czgtr.jpg","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]}]},{"ID":"20241015203772-l1flj6q","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241015203772-l1flj6q","updated":"20241015203772"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#jdk-和-jre","TextMarkTextContent":"JDK 和 JRE"}]},{"ID":"20241015203773-g1y3d5z","Type":"NodeParagraph","Properties":{"id":"20241015203773-g1y3d5z","updated":"20241015203773"},"Children":[{"Type":"NodeText","Data":"JDK（Java Development Kit）是一个功能齐全的 Java 开发工具包，供开发者使用，用于创建和编译 Java 程序。它包含了 JRE（Java Runtime Environment），以及编译器 javac 和其他工具，如 javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等。"}]},{"ID":"20241015203774-xz1cnka","Type":"NodeParagraph","Properties":{"id":"20241015203774-xz1cnka","updated":"20241015203774"},"Children":[{"Type":"NodeText","Data":"JRE 是运行已编译 Java 程序所需的环境，主要包含以下两个部分："}]},{"ID":"20241015203775-yihyhi1","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203775-yihyhi1","updated":"20241015203775"},"Children":[{"ID":"20241015203776-ndrngdb","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203776-ndrngdb","updated":"20241015203776"},"Children":[{"ID":"20241015203777-vs4r3g2","Type":"NodeParagraph","Properties":{"id":"20241015203777-vs4r3g2","updated":"20241015203777"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JVM"},{"Type":"NodeText","Data":" : 也就是我们上面提到的 Java 虚拟机。"}]}]},{"ID":"20241015203778-38r4vq6","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015203778-38r4vq6","updated":"20241015203778"},"Children":[{"ID":"20241015203779-o1nhlea","Type":"NodeParagraph","Properties":{"id":"20241015203779-o1nhlea","updated":"20241015203779"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 基础类库（Class Library）"},{"Type":"NodeText","Data":"：一组标准的类库，提供常用的功能和 API（如 I/O 操作、网络通信、数据结构等）。"}]}]}]},{"ID":"20241015203780-i6l36jk","Type":"NodeParagraph","Properties":{"id":"20241015203780-i6l36jk","updated":"20241015203780"},"Children":[{"Type":"NodeText","Data":"简单来说，JRE 只包含运行 Java 程序所需的环境和类库，而 JDK 不仅包含 JRE，还包括用于开发和调试 Java 程序的工具。"}]},{"ID":"20241015203781-a2s9jd4","Type":"NodeParagraph","Properties":{"id":"20241015203781-a2s9jd4","updated":"20241015203781"},"Children":[{"Type":"NodeText","Data":"如果需要编写、编译 Java 程序或使用 Java API 文档，就需要安装 JDK。某些需要 Java 特性的应用程序（如 JSP 转换为 Servlet 或使用反射）也可能需要 JDK 来编译和运行 Java 代码。因此，即使不进行 Java 开发工作，有时也可能需要安装 JDK。"}]},{"ID":"20241015203782-lsiny1w","Type":"NodeParagraph","Properties":{"id":"20241015203782-lsiny1w","updated":"20241015203782"},"Children":[{"Type":"NodeText","Data":"下图清晰展示了 JDK、JRE 和 JVM 的关系。"}]},{"ID":"20241015203783-twbkyg7","Type":"NodeParagraph","Properties":{"id":"20241015203783-twbkyg7","updated":"20241015203783"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"jdk-include-jre","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/jdk-include-jre-20241015204334-jo4903t.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"jdk-include-jre"}]},{"ID":"20241015203784-qpe0jh2","Type":"NodeParagraph","Properties":{"id":"20241015203784-qpe0jh2","updated":"20241015203784"},"Children":[{"Type":"NodeText","Data":"不过，从 JDK 9 开始，就不需要区分 JDK 和 JRE 的关系了，取而代之的是模块系统（JDK 被重新组织成 94 个模块）+ "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"http://openjdk.java.net/jeps/282","TextMarkTextContent":"jlinkopen in new window"},{"Type":"NodeText","Data":" 工具 (随 Java 9 一起发布的新命令行工具，用于生成自定义 Java 运行时映像，该映像仅包含给定应用程序所需的模块) 。并且，从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。"}]},{"ID":"20241015203785-vuw9ilt","Type":"NodeParagraph","Properties":{"id":"20241015203785-vuw9ilt","updated":"20241015203785"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/new-features/java9.html","TextMarkTextContent":"Java 9 新特性概览open in new window"},{"Type":"NodeText","Data":"这篇文章中，我在介绍模块化系统的时候提到："}]},{"ID":"20241015203786-e927pbc","Type":"NodeBlockquote","Properties":{"id":"20241015203786-e927pbc","updated":"20241015203786"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015203787-pqdvif9","Type":"NodeParagraph","Properties":{"id":"20241015203787-pqdvif9","updated":"20241015203787"},"Children":[{"Type":"NodeText","Data":"在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。"}]}]},{"ID":"20241015203788-9bhzdt9","Type":"NodeParagraph","Properties":{"id":"20241015203788-9bhzdt9","updated":"20241015203788"},"Children":[{"Type":"NodeText","Data":"也就是说，可以用 jlink 根据自己的需求，创建一个更小的 runtime（运行时），而不是不管什么应用，都是同样的 JRE。"}]},{"ID":"20241015203789-j6zdfd7","Type":"NodeParagraph","Properties":{"id":"20241015203789-j6zdfd7","updated":"20241015203789"},"Children":[{"Type":"NodeText","Data":"定制的、模块化的 Java 运行时映像有助于简化 Java 应用的部署和节省内存并增强安全性和可维护性。这对于满足现代应用程序架构的需求，如虚拟化、容器化、微服务和云原生开发，是非常重要的。"}]},{"ID":"20241015203790-9khra9g","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241015203790-9khra9g","updated":"20241015203790"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"👉总结一下"}]},{"ID":"20241015203791-145adfd","Type":"NodeParagraph","Properties":{"id":"20241015203791-145adfd","updated":"20241015203791"},"Children":[{"Type":"NodeText","Data":"JVM + Java基础类库 = JRE；"}]},{"ID":"20241015203792-8efpsxf","Type":"NodeParagraph","Properties":{"id":"20241015203792-8efpsxf","updated":"20241015203792"},"Children":[{"Type":"NodeText","Data":"JRE +（编译器javac、调试器jdb，文档，反编译工具）= JDK；"}]},{"ID":"20241015203793-pktjdf2","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203793-pktjdf2","updated":"20241015203793"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#什么是字节码-采用字节码的好处是什么","TextMarkTextContent":"什么是字节码？"}]},{"ID":"20241015203794-d7eb8qj","Type":"NodeParagraph","Properties":{"id":"20241015203794-d7eb8qj","updated":"20241015203794"},"Children":[{"Type":"NodeText","Data":"在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。"}]},{"ID":"20241015203795-gv0k4rv","Type":"NodeParagraph","Properties":{"id":"20241015203795-gv0k4rv","updated":"20241015203795"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 程序从源代码到运行的过程如下图所示"},{"Type":"NodeText","Data":"："}]},{"ID":"20241015203796-jdyig8r","Type":"NodeParagraph","Properties":{"id":"20241015203796-jdyig8r","updated":"20241015203796"},"Children":[{"Type":"NodeImage","Properties":{"id":""},"Children":[{"Type":"NodeBang","Data":"!","Properties":{"id":""}},{"Type":"NodeOpenBracket","Data":"[","Properties":{"id":""}},{"Type":"NodeLinkText","Data":"Java程序转变为机器代码的过程","Properties":{"id":""}},{"Type":"NodeCloseBracket","Data":"]","Properties":{"id":""}},{"Type":"NodeOpenParen","Data":"(","Properties":{"id":""}},{"Type":"NodeLinkDest","Data":"assets/java-code-to-machine-code-20241015204334-jv1f1bu.png","Properties":{"id":""}},{"Type":"NodeCloseParen","Data":")","Properties":{"id":""}}]},{"Type":"NodeText","Data":"Java程序转变为机器代码的过程"}]},{"ID":"20241015203797-uqcr5sk","Type":"NodeParagraph","Properties":{"id":"20241015203797-uqcr5sk","updated":"20241015203797"},"Children":[{"Type":"NodeText","Data":"我们需要格外注意的是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class-\u0026gt;机器码"},{"Type":"NodeText","Data":" 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"JIT（Just in Time Compilation）"},{"Type":"NodeText","Data":" 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 是编译与解释共存的语言"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20241015203798-nwarw92","Type":"NodeParagraph","Properties":{"id":"20241015203798-nwarw92","updated":"20241015203798"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说 Java 语言“编译与解释并存”？"}]},{"ID":"20241015203799-9fozopp","Type":"NodeParagraph","Properties":{"id":"20241015203799-9fozopp","updated":"20241015203799"},"Children":[{"Type":"NodeText","Data":"这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a strong","TextMarkTextContent":"先编译，后解释"},{"Type":"NodeText","Data":"两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件），这种字节码必须由 Java 解释器来解释执行。"}]},{"ID":"20241015203800-et6n5pw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241015203800-et6n5pw","updated":"20241015203800"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeText","Data":"先编译后解释"}]},{"ID":"20241015203801-qrr30e6","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203801-qrr30e6","updated":"20241015203801"},"Children":[{"ID":"20241015203802-s36f9j8","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203802-s36f9j8","updated":"20241015203802"},"Children":[{"ID":"20241015203803-rk8rt28","Type":"NodeParagraph","Properties":{"id":"20241015203803-rk8rt28","updated":"20241015203803"},"Children":[{"Type":"NodeText","Data":"是的，Java 程序通常要先经过"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译"},{"Type":"NodeText","Data":"，然后再由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释器"},{"Type":"NodeText","Data":"执行，这就是所谓的“先编译、后解释”的执行过程。具体来说，Java 的执行过程分为以下几个步骤："}]},{"ID":"20241015203804-qwobbzr","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203804-qwobbzr","updated":"20241015203804"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"1. "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译阶段"}]},{"ID":"20241015203805-90x7oia","Type":"NodeParagraph","Properties":{"id":"20241015203805-90x7oia","updated":"20241015203805"},"Children":[{"Type":"NodeText","Data":"Java 源代码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".java"},{"Type":"NodeText","Data":" 文件）首先由"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java 编译器"},{"Type":"NodeText","Data":"（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"javac"},{"Type":"NodeText","Data":"）编译成"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"字节码"},{"Type":"NodeText","Data":"文件（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件）。这个字节码文件并不是直接运行在硬件上的机器码，而是一种中间形式，适用于 Java 虚拟机（JVM）。"}]},{"ID":"20241015203806-pwcqf67","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203806-pwcqf67","updated":"20241015203806"},"Children":[{"ID":"20241015203807-3fxu637","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203807-3fxu637","updated":"20241015203807"},"Children":[{"ID":"20241015203808-x5zl0ly","Type":"NodeParagraph","Properties":{"id":"20241015203808-x5zl0ly","updated":"20241015203808"},"Children":[{"Type":"NodeText","Data":"Java 编译器把可读的源代码转换为字节码，字节码相对独立于具体的硬件平台。"}]}]}]},{"ID":"20241015203809-lfq2w3g","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203809-lfq2w3g","updated":"20241015203809"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"2. "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释阶段"}]},{"ID":"20241015203810-kf0qlfi","Type":"NodeParagraph","Properties":{"id":"20241015203810-kf0qlfi","updated":"20241015203810"},"Children":[{"Type":"NodeText","Data":"编译生成的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件并不能直接在操作系统中运行，而需要通过"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"Java 虚拟机（JVM）"},{"Type":"NodeText","Data":"来执行。"}]},{"ID":"20241015203811-o6ipm50","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203811-o6ipm50","updated":"20241015203811"},"Children":[{"ID":"20241015203812-ls7gie9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203812-ls7gie9","updated":"20241015203812"},"Children":[{"ID":"20241015203813-b5hn9j2","Type":"NodeParagraph","Properties":{"id":"20241015203813-b5hn9j2","updated":"20241015203813"},"Children":[{"Type":"NodeText","Data":"当 JVM 运行字节码时，JVM 会将字节码解释成对应平台的机器码，逐行执行。这一步叫做"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20241015203814-83001yi","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203814-83001yi","updated":"20241015203814"},"Children":[{"ID":"20241015203815-05b9oza","Type":"NodeParagraph","Properties":{"id":"20241015203815-05b9oza","updated":"20241015203815"},"Children":[{"Type":"NodeText","Data":"Java 使用的 JVM 解释器将 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":" 文件中的字节码逐步翻译成特定系统的机器码并执行。"}]}]}]},{"ID":"20241015203816-gs5x972","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203816-gs5x972","updated":"20241015203816"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"3. "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"即时编译 (JIT, Just-In-Time Compilation)"}]},{"ID":"20241015203817-is3my47","Type":"NodeParagraph","Properties":{"id":"20241015203817-is3my47","updated":"20241015203817"},"Children":[{"Type":"NodeText","Data":"为了提高性能，JVM 还会利用"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"即时编译器（JIT Compiler）"},{"Type":"NodeText","Data":"。当 JVM 发现某些代码块经常被执行时，JIT 会将这些字节码编译成机器码，并缓存起来，这样下次执行时可以直接运行机器码，而无需再解释字节码。"}]},{"ID":"20241015203818-ssr092m","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203818-ssr092m","updated":"20241015203818"},"Children":[{"ID":"20241015203819-qq6j99x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203819-qq6j99x","updated":"20241015203819"},"Children":[{"ID":"20241015203820-2fg13pn","Type":"NodeParagraph","Properties":{"id":"20241015203820-2fg13pn","updated":"20241015203820"},"Children":[{"Type":"NodeText","Data":"JIT 使得 Java 程序在执行过程中可以动态优化和加速。"}]}]}]},{"ID":"20241015203821-jz59aup","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203821-jz59aup","updated":"20241015203821"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"整体过程总结："}]},{"ID":"20241015203822-1afskyj","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203822-1afskyj","updated":"20241015203822"},"Children":[{"ID":"20241015203823-vowk1i8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203823-vowk1i8","updated":"20241015203823"},"Children":[{"ID":"20241015203824-6as8vck","Type":"NodeParagraph","Properties":{"id":"20241015203824-6as8vck","updated":"20241015203824"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"编译"},{"Type":"NodeText","Data":"：源代码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".java"},{"Type":"NodeText","Data":"）编译为字节码（"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":".class"},{"Type":"NodeText","Data":"），与平台无关。"}]}]},{"ID":"20241015203825-mqwr5n1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203825-mqwr5n1","updated":"20241015203825"},"Children":[{"ID":"20241015203826-p3h2ukb","Type":"NodeParagraph","Properties":{"id":"20241015203826-p3h2ukb","updated":"20241015203826"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"解释"},{"Type":"NodeText","Data":"：JVM 将字节码解释为机器码，并执行。"}]}]},{"ID":"20241015203827-np1hlyp","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203827-np1hlyp","updated":"20241015203827"},"Children":[{"ID":"20241015203828-04vn4q3","Type":"NodeParagraph","Properties":{"id":"20241015203828-04vn4q3","updated":"20241015203828"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"即时编译"},{"Type":"NodeText","Data":"：JIT 编译器会在运行时将热代码编译为本地机器码，提升性能。"}]}]}]},{"ID":"20241015203829-2ub2nog","Type":"NodeParagraph","Properties":{"id":"20241015203829-2ub2nog","updated":"20241015203829"},"Children":[{"Type":"NodeText","Data":"因此，Java 是一种“先编译、后解释”的语言。"}]}]}]},{"ID":"20241015203830-p6ly9t8","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015203830-p6ly9t8","updated":"20241015203830"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#java-和-c-的区别","TextMarkTextContent":"Java 和 C++ 的区别?"}]},{"ID":"20241015203831-5iwcps3","Type":"NodeParagraph","Properties":{"id":"20241015203831-5iwcps3","updated":"20241015203831"},"Children":[{"Type":"NodeText","Data":"我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。"}]},{"ID":"20241015203832-hc0mu33","Type":"NodeParagraph","Properties":{"id":"20241015203832-hc0mu33","updated":"20241015203832"},"Children":[{"Type":"NodeText","Data":"虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方："}]},{"ID":"20241015203833-se0lc6y","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203833-se0lc6y","updated":"20241015203833"},"Children":[{"ID":"20241015203834-771dlf1","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203834-771dlf1","updated":"20241015203834"},"Children":[{"ID":"20241015203835-f3zyfg0","Type":"NodeParagraph","Properties":{"id":"20241015203835-f3zyfg0","updated":"20241015203835"},"Children":[{"Type":"NodeText","Data":"Java 不提供指针来直接访问内存，程序内存更加安全"}]}]},{"ID":"20241015203836-dfiq2iy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203836-dfiq2iy","updated":"20241015203836"},"Children":[{"ID":"20241015203837-ivg0wy4","Type":"NodeParagraph","Properties":{"id":"20241015203837-ivg0wy4","updated":"20241015203837"},"Children":[{"Type":"NodeText","Data":"Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。"}]}]},{"ID":"20241015203838-11g0oaj","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203838-11g0oaj","updated":"20241015203838"},"Children":[{"ID":"20241015203839-9azrue4","Type":"NodeParagraph","Properties":{"id":"20241015203839-9azrue4","updated":"20241015203839"},"Children":[{"Type":"NodeText","Data":"Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。"}]}]},{"ID":"20241015203840-8bxlnbl","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203840-8bxlnbl","updated":"20241015203840"},"Children":[{"ID":"20241015203841-pu7o1vv","Type":"NodeParagraph","Properties":{"id":"20241015203841-pu7o1vv","updated":"20241015203841"},"Children":[{"Type":"NodeText","Data":"C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。"}]}]}]},{"ID":"20241015203842-u2v38v4","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015203842-u2v38v4","updated":"20241015204603"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#java-中的几种基本数据类型了解么","TextMarkTextContent":"Java 中的几种基本数据类型？"}]},{"ID":"20241015203843-y8v3edh","Type":"NodeParagraph","Properties":{"id":"20241015203843-y8v3edh","updated":"20241015203843"},"Children":[{"Type":"NodeText","Data":"Java 中有 8 种基本数据类型，分别为："}]},{"ID":"20241015203844-y113rj6","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203844-y113rj6","updated":"20241015203844"},"Children":[{"ID":"20241015203845-eqfzvgm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203845-eqfzvgm","updated":"20241015203845"},"Children":[{"ID":"20241015203846-bpnpgos","Type":"NodeParagraph","Properties":{"id":"20241015203846-bpnpgos","updated":"20241015203846"},"Children":[{"Type":"NodeText","Data":"6 种数字类型："}]},{"ID":"20241015203847-5q6pst2","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203847-5q6pst2","updated":"20241015203847"},"Children":[{"ID":"20241015203848-8zwbmig","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203848-8zwbmig","updated":"20241015203848"},"Children":[{"ID":"20241015203849-8h7bu75","Type":"NodeParagraph","Properties":{"id":"20241015203849-8h7bu75","updated":"20241015203849"},"Children":[{"Type":"NodeText","Data":"4 种整数型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"}]}]},{"ID":"20241015203850-sflf8hv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203850-sflf8hv","updated":"20241015203850"},"Children":[{"ID":"20241015203851-6unxhca","Type":"NodeParagraph","Properties":{"id":"20241015203851-6unxhca","updated":"20241015203851"},"Children":[{"Type":"NodeText","Data":"2 种浮点型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"double"}]}]}]}]},{"ID":"20241015203852-1ci3v6x","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203852-1ci3v6x","updated":"20241015203852"},"Children":[{"ID":"20241015203853-xxhyo9c","Type":"NodeParagraph","Properties":{"id":"20241015203853-xxhyo9c","updated":"20241015203853"},"Children":[{"Type":"NodeText","Data":"1 种字符类型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"}]}]},{"ID":"20241015203854-li75t3v","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203854-li75t3v","updated":"20241015203854"},"Children":[{"ID":"20241015203855-4e0g9b8","Type":"NodeParagraph","Properties":{"id":"20241015203855-4e0g9b8","updated":"20241015203855"},"Children":[{"Type":"NodeText","Data":"1 种布尔型："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20241015203856-c30kybo","Type":"NodeParagraph","Properties":{"id":"20241015203856-c30kybo","updated":"20241015203856"},"Children":[{"Type":"NodeText","Data":"这 8 种基本数据类型的默认值以及所占空间的大小如下："}]},{"ID":"20241015203857-xp5s974","Type":"NodeTable","TableAligns":[1,1,1,1,0],"Properties":{"colgroup":"||||","id":"20241015203857-xp5s974","updated":"20241015204603"},"Children":[{"Type":"NodeTableHead","Data":"thead","Children":[{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"基本类型"}]},{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"位数"}]},{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"字节"}]},{"Type":"NodeTableCell","Data":"th","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"默认值"}]},{"Type":"NodeTableCell","Data":"th","Children":[{"Type":"NodeText","Data":"取值范围"}]}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"-128 ~ 127"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"-32768（-2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"15） ~ 32767（2"},{"Type":"NodeText","Data":"15 - 1）"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"0"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"-2147483648 ~ 2147483647"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"0L"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"-9223372036854775808（-2"},{"Type":"NodeTextMark","TextMarkType":"sup","TextMarkTextContent":"63） ~ 9223372036854775807（2"},{"Type":"NodeText","Data":"63 -1）"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"16"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"2"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"'u0000'"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"0 ~ 65535（2"},{"Type":"NodeBackslash","Data":"span","Children":[{"Type":"NodeText","Data":"^"}]},{"Type":"NodeText","Data":"16 - 1）"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"32"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"4"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"0f"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"1.4E-45 ~ 3.4028235E38"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"double"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"64"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"8"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"0d"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"4.9E-324 ~ 1.7976931348623157E308"}]}]},{"Type":"NodeTableRow","Data":"tr","Children":[{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"​"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"1"}]},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1},{"Type":"NodeTableCell","Data":"td","TableCellAlign":1,"Children":[{"Type":"NodeText","Data":"false"}]},{"Type":"NodeTableCell","Data":"td","Children":[{"Type":"NodeText","Data":"true、false"}]}]}]},{"ID":"20241015203858-em88bkp","Type":"NodeParagraph","Properties":{"id":"20241015203858-em88bkp","updated":"20241015203858"},"Children":[{"Type":"NodeText","Data":"可以看到，像 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":"能表示的最大正数都减 1 了。这是为什么呢？这是因为在二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1。如果我们再加 1，就会导致溢出，变成一个负数。"}]},{"ID":"20241015203859-8qpdkcf","Type":"NodeParagraph","Properties":{"id":"20241015203859-8qpdkcf","updated":"20241015203859"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"boolean"},{"Type":"NodeText","Data":"，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。"}]},{"ID":"20241015203860-89plziv","Type":"NodeParagraph","Properties":{"id":"20241015203860-89plziv","updated":"20241015203860"},"Children":[{"Type":"NodeText","Data":"另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。"}]},{"ID":"20241015203861-9stilnr","Type":"NodeParagraph","Properties":{"id":"20241015203861-9stilnr","updated":"20241015203861"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"注意："}]},{"ID":"20241015203862-jdjt8wr","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203862-jdjt8wr","updated":"20241015203862"},"Children":[{"ID":"20241015203863-o3fsxd3","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203863-o3fsxd3","updated":"20241015203863"},"Children":[{"ID":"20241015203864-h7qeyxg","Type":"NodeParagraph","Properties":{"id":"20241015203864-h7qeyxg","updated":"20241015203864"},"Children":[{"Type":"NodeText","Data":"Java 里使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"long"},{"Type":"NodeText","Data":" 类型的数据一定要在数值后面加上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"L"},{"Type":"NodeText","Data":"，否则将作为整型解析。"}]}]},{"ID":"20241015203865-my2yqy3","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015203865-my2yqy3","updated":"20241015203865"},"Children":[{"ID":"20241015203866-hddl172","Type":"NodeParagraph","Properties":{"id":"20241015203866-hddl172","updated":"20241015203866"},"Children":[{"Type":"NodeText","Data":"Java 里使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":" 类型的数据一定要在数值后面加上 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"f 或 F"},{"Type":"NodeText","Data":"，否则将无法通过编译。"}]}]},{"ID":"20241015203867-sdrdf6b","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241015203867-sdrdf6b","updated":"20241015203867"},"Children":[{"ID":"20241015203868-1tlmh0f","Type":"NodeParagraph","Properties":{"id":"20241015203868-1tlmh0f","updated":"20241015203868"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char a = 'h'"},{"Type":"NodeText","Data":"char :单引号，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String a = \u0026quot;hello\u0026quot;"},{"Type":"NodeText","Data":" :双引号。"}]}]}]},{"ID":"20241015203869-ekapbta","Type":"NodeParagraph","Properties":{"id":"20241015203869-ekapbta","updated":"20241015203869"},"Children":[{"Type":"NodeText","Data":"这八种基本类型都有对应的包装类分别为："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20241015203870-69kjn9y","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015203870-69kjn9y","updated":"20241015203870"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#如何解决浮点数运算的精度丢失问题","TextMarkTextContent":"浮点数运算的精度丢失问题？"}]},{"ID":"20241015203871-2jau35n","Type":"NodeParagraph","Properties":{"id":"20241015203871-2jau35n","updated":"20241015203871"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 来做的。"}]},{"ID":"20241015203872-fe9xwbx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203872-fe9xwbx","updated":"20241015203872"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"BigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"1.00\");\nBigDecimal c = new BigDecimal(\"0.8\");\n\nBigDecimal x = a.subtract(c);\nBigDecimal y = b.subtract(c);\n\nSystem.out.println(x); /* 0.2 */\nSystem.out.println(y); /* 0.20 */\n// 比较内容，不是比较值\nSystem.out.println(Objects.equals(x, y)); /* false */\n// 比较值相等用相等compareTo，相等返回0\nSystem.out.println(0 == x.compareTo(y)); /* true */\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203873-z5weovx","Type":"NodeParagraph","Properties":{"id":"20241015203873-z5weovx","updated":"20241015203873"},"Children":[{"Type":"NodeText","Data":"关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"BigDecimal"},{"Type":"NodeText","Data":" 的详细介绍，可以看看我写的这篇文章："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/bigdecimal.html","TextMarkTextContent":"BigDecimal 详解open in new window"},{"Type":"NodeText","Data":"。"}]},{"ID":"20241015203874-j584eg1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015203874-j584eg1","updated":"20241015203874"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"包装类"}]},{"ID":"20241015203875-0lm91sa","Type":"NodeParagraph","Properties":{"id":"20241015203875-0lm91sa","updated":"20241015203875"},"Children":[{"Type":"NodeText","Data":"https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88"}]},{"ID":"20241015203876-8zm3tdu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203876-8zm3tdu","updated":"20241015203876"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#基本类型和包装类型的区别","TextMarkTextContent":"基本类型和包装类型的区别？"}]},{"ID":"20241015203877-oix0u1t","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203877-oix0u1t","updated":"20241015203877"},"Children":[{"ID":"20241015203878-ka2xed9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203878-ka2xed9","updated":"20241015203878"},"Children":[{"ID":"20241015203879-d6g88qw","Type":"NodeParagraph","Properties":{"id":"20241015203879-d6g88qw","updated":"20241015203879"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"用途"},{"Type":"NodeText","Data":"：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。"}]}]},{"ID":"20241015203880-p3qate8","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203880-p3qate8","updated":"20241015203880"},"Children":[{"ID":"20241015203881-e39jihp","Type":"NodeParagraph","Properties":{"id":"20241015203881-e39jihp","updated":"20241015203881"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储方式"},{"Type":"NodeText","Data":"：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。"}]}]},{"ID":"20241015203882-oj60g20","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203882-oj60g20","updated":"20241015203882"},"Children":[{"ID":"20241015203883-ma828kn","Type":"NodeParagraph","Properties":{"id":"20241015203883-ma828kn","updated":"20241015203883"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占用空间"},{"Type":"NodeText","Data":"：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。"}]}]},{"ID":"20241015203884-wnrhmu9","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203884-wnrhmu9","updated":"20241015203884"},"Children":[{"ID":"20241015203885-snqo8nd","Type":"NodeParagraph","Properties":{"id":"20241015203885-snqo8nd","updated":"20241015203885"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值"},{"Type":"NodeText","Data":"：成员变量包装类型不赋值就是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":" ，而基本类型有默认值且不是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"null"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20241015203886-jv04oxm","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203886-jv04oxm","updated":"20241015203886"},"Children":[{"ID":"20241015203887-5t878yd","Type":"NodeParagraph","Properties":{"id":"20241015203887-5t878yd","updated":"20241015203887"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"比较方式"},{"Type":"NodeText","Data":"：对于基本数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是值。对于包装数据类型来说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":" 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"equals()"},{"Type":"NodeText","Data":" 方法。"}]}]}]},{"ID":"20241015203888-6axfr6e","Type":"NodeParagraph","Properties":{"id":"20241015203888-6axfr6e","updated":"20241015203888"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么说是几乎所有对象实例都存在于堆中呢？"},{"Type":"NodeText","Data":" 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存"}]},{"ID":"20241015203889-pl147f5","Type":"NodeParagraph","Properties":{"id":"20241015203889-pl147f5","updated":"20241015203889"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"基本数据类型存放在栈中是一个常见的误区！"},{"Type":"NodeText","Data":" 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。"}]},{"ID":"20241015203890-5b65ftx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203890-5b65ftx","updated":"20241015203890"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Test {\n    // 成员变量，存放在堆中\n    int a = 10;\n    // 被 static 修饰，也存放在堆中，但属于类，不属于对象\n    // JDK1.7 静态变量从永久代移动了 Java 堆中\n    static int b = 20;\n\n    public void method() {\n        // 局部变量，存放在栈中\n        int c = 30;\n        static int d = 40; // 编译错误，不能在方法中使用 static 修饰局部变量\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203891-vt0ttmo","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203891-vt0ttmo","updated":"20241015203891"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#包装类型的缓存机制了解么","TextMarkTextContent":"包装类型的缓存机制了解么？"}]},{"ID":"20241015203892-kavm5of","Type":"NodeParagraph","Properties":{"id":"20241015203892-kavm5of","updated":"20241015203892"},"Children":[{"Type":"NodeText","Data":"Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。"}]},{"ID":"20241015203893-oyd2qc0","Type":"NodeParagraph","Properties":{"id":"20241015203893-oyd2qc0","updated":"20241015203893"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Byte"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Short"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Long"},{"Type":"NodeText","Data":" 这 4 种包装类默认创建了数值 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[-128，127]"},{"Type":"NodeText","Data":" 的相应类型的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Character"},{"Type":"NodeText","Data":" 创建了数值在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"[0,127]"},{"Type":"NodeText","Data":" 范围的缓存数据，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Boolean"},{"Type":"NodeText","Data":" 直接返回 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"True"},{"Type":"NodeText","Data":" or "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"False"},{"Type":"NodeText","Data":"。"}]},{"ID":"20241015203894-sexanf3","Type":"NodeParagraph","Properties":{"id":"20241015203894-sexanf3","updated":"20241015203894"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Integer 缓存源码："}]},{"ID":"20241015203895-if6vn2u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203895-if6vn2u","updated":"20241015203895"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Integer valueOf(int i) {\n    if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static {\n        // high value may be configured by property\n        int h = 127;\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203896-eh72fh9","Type":"NodeParagraph","Properties":{"id":"20241015203896-eh72fh9","updated":"20241015203896"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Character"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码:"}]},{"ID":"20241015203897-4jzt0z1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203897-4jzt0z1","updated":"20241015203897"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Character valueOf(char c) {\n    if (c \u003c= 127) { // must cache\n      return CharacterCache.cache[(int)c];\n    }\n    return new Character(c);\n}\n\nprivate static class CharacterCache {\n    private CharacterCache(){}\n    static final Character cache[] = new Character[127 + 1];\n    static {\n        for (int i = 0; i \u003c cache.length; i++)\n            cache[i] = new Character((char)i);\n    }\n\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203898-hmioqnd","Type":"NodeParagraph","Properties":{"id":"20241015203898-hmioqnd","updated":"20241015203898"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"Boolean"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 缓存源码："}]},{"ID":"20241015203899-5fxqf0r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203899-5fxqf0r","updated":"20241015203899"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203900-wmsru21","Type":"NodeParagraph","Properties":{"id":"20241015203900-wmsru21","updated":"20241015203900"},"Children":[{"Type":"NodeText","Data":"如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。"}]},{"ID":"20241015203901-akrhhmn","Type":"NodeParagraph","Properties":{"id":"20241015203901-akrhhmn","updated":"20241015203901"},"Children":[{"Type":"NodeText","Data":"两种浮点数类型的包装类 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Float"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Double"},{"Type":"NodeText","Data":" 并没有实现缓存机制。"}]},{"ID":"20241015203902-5juixk1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203902-5juixk1","updated":"20241015203902"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出 true\n\nFloat i11 = 333f;\nFloat i22 = 333f;\nSystem.out.println(i11 == i22);// 输出 false\n\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出 false\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203903-cv5bqly","Type":"NodeParagraph","Properties":{"id":"20241015203903-cv5bqly","updated":"20241015203903"},"Children":[{"Type":"NodeText","Data":"下面我们来看一个问题：下面的代码的输出结果是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":" 还是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 呢？"}]},{"ID":"20241015203904-ga6tohm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203904-ga6tohm","updated":"20241015203904"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = 40;\nInteger i2 = new Integer(40);\nSystem.out.println(i1==i2);\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203905-y4cudny","Type":"NodeParagraph","Properties":{"id":"20241015203905-y4cudny","updated":"20241015203905"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=40"},{"Type":"NodeText","Data":" 这一行代码会发生装箱，也就是说这行代码等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1=Integer.valueOf(40)"},{"Type":"NodeText","Data":" 。因此，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i1"},{"Type":"NodeText","Data":" 直接使用的是缓存中的对象。而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i2 = new Integer(40)"},{"Type":"NodeText","Data":" 会直接创建新的对象。"}]},{"ID":"20241015203906-5nqc3zx","Type":"NodeParagraph","Properties":{"id":"20241015203906-5nqc3zx","updated":"20241015203906"},"Children":[{"Type":"NodeText","Data":"因此，答案是 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"false"},{"Type":"NodeText","Data":" 。你答对了吗？"}]},{"ID":"20241015203907-n1f1ba5","Type":"NodeParagraph","Properties":{"id":"20241015203907-n1f1ba5","updated":"20241015203907"},"Children":[{"Type":"NodeText","Data":"记住："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"所有整型包装类对象之间值的比较，全部使用 equals 方法比较"},{"Type":"NodeText","Data":"。"}]},{"ID":"20241015203908-p0rqr1b","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203908-p0rqr1b","updated":"20241015203908"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"为什么是false？"}]},{"ID":"20241015203909-rrb8cbd","Type":"NodeParagraph","Properties":{"id":"20241015203909-rrb8cbd","updated":"20241015203909"},"Children":[{"Type":"NodeText","Data":"为什么是false？"}]},{"ID":"20241015203910-4th2214","Type":"NodeParagraph","Properties":{"id":"20241015203910-4th2214","updated":"20241015203910"},"Children":[{"Type":"NodeText","Data":"是的，通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"new Integer(40)"},{"Type":"NodeText","Data":" 显式创建的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":" 对象并不会使用缓存机制。每次使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"new"},{"Type":"NodeText","Data":" 关键字创建对象时，都会在堆内存中分配一个新的对象实例，即使这个值与缓存中的值相同。因此，即使 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i2"},{"Type":"NodeText","Data":" 的值与 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"i1"},{"Type":"NodeText","Data":" 相同，它们的引用却是不同的。"}]},{"ID":"20241015203911-ecbfnne","Type":"NodeParagraph","Properties":{"id":"20241015203911-ecbfnne","updated":"20241015203911"},"Children":[{"Type":"NodeText","Data":"Java 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer"},{"Type":"NodeText","Data":" 类在 -128 到 127 范围内确实使用了缓存机制，也就是说在这个范围内的整数会返回同一个实例。如果你用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i1 = 40;"},{"Type":"NodeText","Data":"，它会返回缓存中的实例，而 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"new Integer(40)"},{"Type":"NodeText","Data":" 则会始终创建一个新的对象实例。"}]},{"ID":"20241015203912-l2s8vrr","Type":"NodeParagraph","Properties":{"id":"20241015203912-l2s8vrr","updated":"20241015203912"},"Children":[{"Type":"NodeText","Data":"如果要使用缓存机制而不显式创建新的对象，可以直接使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer.valueOf(40)"},{"Type":"NodeText","Data":"，这样会返回缓存中的实例（如果在范围内）："}]},{"ID":"20241015203913-6xtuw9x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203913-6xtuw9x","updated":"20241015203913"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i1 = Integer.valueOf(40); // 使用缓存\nInteger i2 = Integer.valueOf(40); // 也使用缓存\nSystem.out.println(i1 == i2); // 这将输出 true\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203914-stdxxy5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203914-stdxxy5","updated":"20241015203914"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"装箱和拆箱"}]},{"ID":"20241015203915-9thzm6e","Type":"NodeParagraph","Properties":{"id":"20241015203915-9thzm6e","updated":"20241015203915"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"什么是自动拆装箱？"}]},{"ID":"20241015203916-qqqu1gq","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203916-qqqu1gq","updated":"20241015203916"},"Children":[{"ID":"20241015203917-wzixc8i","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203917-wzixc8i","updated":"20241015203917"},"Children":[{"ID":"20241015203918-g9br1ee","Type":"NodeParagraph","Properties":{"id":"20241015203918-g9br1ee","updated":"20241015203918"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"装箱"},{"Type":"NodeText","Data":"：将基本类型用它们对应的引用类型包装起来；"}]}]},{"ID":"20241015203919-gfb33xd","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203919-gfb33xd","updated":"20241015203919"},"Children":[{"ID":"20241015203920-5fcgmf3","Type":"NodeParagraph","Properties":{"id":"20241015203920-5fcgmf3","updated":"20241015203920"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"拆箱"},{"Type":"NodeText","Data":"：将包装类型转换为基本数据类型；"}]}]}]},{"ID":"20241015203921-wmi6n8t","Type":"NodeParagraph","Properties":{"id":"20241015203921-wmi6n8t","updated":"20241015203921"},"Children":[{"Type":"NodeText","Data":"举例："}]},{"ID":"20241015203922-cydoy38","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203922-cydoy38","updated":"20241015203922"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"Integer i = 10;  //装箱\nint n = i;   //拆箱\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203923-4kk6qjb","Type":"NodeParagraph","Properties":{"id":"20241015203923-4kk6qjb","updated":"20241015203923"},"Children":[{"Type":"NodeText","Data":"因此，"}]},{"ID":"20241015203924-ydcsiv5","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203924-ydcsiv5","updated":"20241015203924"},"Children":[{"ID":"20241015203925-5mf4dd3","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203925-5mf4dd3","updated":"20241015203925"},"Children":[{"ID":"20241015203926-urtcjxf","Type":"NodeParagraph","Properties":{"id":"20241015203926-urtcjxf","updated":"20241015203926"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = 10"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"Integer i = Integer.valueOf(10)"}]}]},{"ID":"20241015203927-t1qg21z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203927-t1qg21z","updated":"20241015203927"},"Children":[{"ID":"20241015203928-2fs6szx","Type":"NodeParagraph","Properties":{"id":"20241015203928-2fs6szx","updated":"20241015203928"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i"},{"Type":"NodeText","Data":" 等价于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int n = i.intValue()"},{"Type":"NodeText","Data":";"}]}]}]},{"ID":"20241015203929-7l5rphv","Type":"NodeParagraph","Properties":{"id":"20241015203929-7l5rphv","updated":"20241015203929"},"Children":[{"Type":"NodeText","Data":"注意："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。"}]},{"ID":"20241015203930-h3kw0bf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203930-h3kw0bf","updated":"20241015203930"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"private static long sum() {\n    // 应该使用 long 而不是 Long\n    Long sum = 0L;\n    for (long i = 0; i \u003c= Integer.MAX_VALUE; i++)\n        sum += i;\n    return sum;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203931-c4dc1tv","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015203931-c4dc1tv","updated":"20241015203931"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"变量"}]},{"ID":"20241015203932-9nfpjug","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203932-9nfpjug","updated":"20241015203932"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#成员变量与局部变量的区别","TextMarkTextContent":"成员变量与局部变量的区别？"}]},{"ID":"20241015203933-lu3ola0","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203933-lu3ola0","updated":"20241015203933"},"Children":[{"ID":"20241015203934-euouv1z","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203934-euouv1z","updated":"20241015203934"},"Children":[{"ID":"20241015203935-gzza1ww","Type":"NodeParagraph","Properties":{"id":"20241015203935-gzza1ww","updated":"20241015203935"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"语法形式"},{"Type":"NodeText","Data":"：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"public"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 等修饰符所修饰，而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"局部变量不能被"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkTextContent":"public"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkTextContent":"private"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":","},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkTextContent":"static"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":" 所修饰"},{"Type":"NodeText","Data":"；但是，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"成员变量和局部变量都能被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":" 所修饰"},{"Type":"NodeText","Data":"。"}]}]},{"ID":"20241015203936-hkk7by7","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203936-hkk7by7","updated":"20241015203936"},"Children":[{"ID":"20241015203937-87gccjx","Type":"NodeParagraph","Properties":{"id":"20241015203937-87gccjx","updated":"20241015203937"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"存储方式"},{"Type":"NodeText","Data":"：从变量在内存中的存储方式来看，如果成员变量是使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的，那么这个成员变量是属于类的，如果没有使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。"}]}]},{"ID":"20241015203938-yi4tfrt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203938-yi4tfrt","updated":"20241015203938"},"Children":[{"ID":"20241015203939-lgu4i5o","Type":"NodeParagraph","Properties":{"id":"20241015203939-lgu4i5o","updated":"20241015203939"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"生存时间"},{"Type":"NodeText","Data":"：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。"}]}]},{"ID":"20241015203940-homw0yv","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203940-homw0yv","updated":"20241015203940"},"Children":[{"ID":"20241015203941-3eeryfm","Type":"NodeParagraph","Properties":{"id":"20241015203941-3eeryfm","updated":"20241015203941"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"默认值"},{"Type":"NodeText","Data":"：从变量是否有默认值来看，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值"},{"Type":"NodeText","Data":"（一种情况例外:被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的成员变量也必须显式地赋值），而"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"局部变量则不会自动赋值"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20241015203942-32ls538","Type":"NodeParagraph","Properties":{"id":"20241015203942-32ls538","updated":"20241015203942"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"为什么成员变量有默认值？"}]},{"ID":"20241015203943-m0va3lh","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203943-m0va3lh","updated":"20241015203943"},"Children":[{"ID":"20241015203944-92srorr","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203944-92srorr","updated":"20241015203944"},"Children":[{"ID":"20241015203945-318niee","Type":"NodeParagraph","Properties":{"id":"20241015203945-318niee","updated":"20241015203945"},"Children":[{"Type":"NodeText","Data":"先不考虑变量类型，如果没有默认值会怎样？变量存储的是内存地址对应的任意随机值，程序读取该值运行会出现意外。"}]}]},{"ID":"20241015203946-3k5jwp4","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015203946-3k5jwp4","updated":"20241015203946"},"Children":[{"ID":"20241015203947-5bxet0t","Type":"NodeParagraph","Properties":{"id":"20241015203947-5bxet0t","updated":"20241015203947"},"Children":[{"Type":"NodeText","Data":"默认值有两种设置方式：手动和自动，根据第一点，没有手动赋值一定要自动赋值。成员变量在运行时可借助反射等方法手动赋值，而局部变量不行。"}]}]},{"ID":"20241015203948-bz22tkw","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241015203948-bz22tkw","updated":"20241015203948"},"Children":[{"ID":"20241015203949-usg5jwd","Type":"NodeParagraph","Properties":{"id":"20241015203949-usg5jwd","updated":"20241015203949"},"Children":[{"Type":"NodeText","Data":"对于编译器（javac）来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”又会影响用户体验，所以采用自动赋默认值。"}]}]}]},{"ID":"20241015203950-jvyjgus","Type":"NodeParagraph","Properties":{"id":"20241015203950-jvyjgus","updated":"20241015203950"},"Children":[{"Type":"NodeText","Data":"成员变量与局部变量代码示例："}]},{"ID":"20241015203951-26hb13f","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203951-26hb13f","updated":"20241015203951"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VariableExample {\n\n    // 成员变量\n    private String name;\n    private int age;\n\n    // 方法中的局部变量\n    public void method() {\n        int num1 = 10; // 栈中分配的局部变量\n        String str = \"Hello, world!\"; // 栈中分配的局部变量\n        System.out.println(num1);\n        System.out.println(str);\n    }\n\n    // 带参数的方法中的局部变量\n    public void method2(int num2) {\n        int sum = num2 + 10; // 栈中分配的局部变量\n        System.out.println(sum);\n    }\n\n    // 构造方法中的局部变量\n    public VariableExample(String name, int age) {\n        this.name = name; // 对成员变量进行赋值\n        this.age = age; // 对成员变量进行赋值\n        int num3 = 20; // 栈中分配的局部变量\n        String str2 = \"Hello, \" + this.name + \"!\"; // 栈中分配的局部变量\n        System.out.println(num3);\n        System.out.println(str2);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203952-e2aj5g1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203952-e2aj5g1","updated":"20241015203952"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"🚩final修饰符"}]},{"ID":"20241015203953-bl5aqxp","Type":"NodeBlockquote","Properties":{"id":"20241015203953-bl5aqxp","updated":"20241015203953"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015203954-qx2w4dy","Type":"NodeParagraph","Properties":{"id":"20241015203954-qx2w4dy","updated":"20241015203954"},"Children":[{"Type":"NodeText","Data":"final与const"}]}]},{"ID":"20241015203955-h2el70h","Type":"NodeList","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203955-h2el70h","updated":"20241015203955"},"Children":[{"ID":"20241015203956-xujwdkh","Type":"NodeListItem","Data":"-","ListData":{"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203956-xujwdkh","updated":"20241015203956"},"Children":[{"ID":"20241015203957-7z46664","Type":"NodeParagraph","Properties":{"id":"20241015203957-7z46664","updated":"20241015203957"},"Children":[{"Type":"NodeText","Data":"Java 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰符与 C++ 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 有类似的作用，但也有一些不同之处。我们来详细看看 Java 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰符的用法及其与 C++ 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 的对比。"}]},{"ID":"20241015203958-gg5exih","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203958-gg5exih","updated":"20241015203958"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰符"}]},{"ID":"20241015203959-4iyxale","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203959-4iyxale","updated":"20241015203959"},"Children":[{"ID":"20241015203960-z7c7bxp","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203960-z7c7bxp","updated":"20241015203960"},"Children":[{"ID":"20241015203961-b9yb6u0","Type":"NodeParagraph","Properties":{"id":"20241015203961-b9yb6u0","updated":"20241015203961"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 变量"},{"Type":"NodeText","Data":"（常量）"}]},{"ID":"20241015203962-xkcorxh","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203962-xkcorxh","updated":"20241015203962"},"Children":[{"ID":"20241015203963-bnww39t","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203963-bnww39t","updated":"20241015203963"},"Children":[{"ID":"20241015203964-ts0cwn4","Type":"NodeParagraph","Properties":{"id":"20241015203964-ts0cwn4","updated":"20241015203964"},"Children":[{"Type":"NodeText","Data":"如果一个变量被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰，那么它在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a strong","TextMarkTextContent":"初始化之后就不能再被改变"},{"Type":"NodeText","Data":"。这类似于 C++ 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 修饰符。"}]}]},{"ID":"20241015203965-3exfjgb","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203965-3exfjgb","updated":"20241015203965"},"Children":[{"ID":"20241015203966-g04c4h8","Type":"NodeParagraph","Properties":{"id":"20241015203966-g04c4h8","updated":"20241015203966"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 可以用于基本数据类型（如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":"、"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"float"},{"Type":"NodeText","Data":"）或引用类型（如对象引用）。如果是基本类型，变量的值不能改变；如果是引用类型，引用的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a strong","TextMarkTextContent":"地址不能改变（即引用的对象不能重新赋值，但对象内部的状态可以改变）"},{"Type":"NodeText","Data":"。"}]}]}]},{"ID":"20241015203967-jfrrq37","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203967-jfrrq37","updated":"20241015203967"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final int x = 10;\nx = 20; // 这会报错，因为 x 已经是 final 的\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015203968-7utz5ck","Type":"NodeParagraph","Properties":{"id":"20241015203968-7utz5ck","updated":"20241015203968"},"Children":[{"Type":"NodeText","Data":"对于对象引用："}]},{"ID":"20241015203969-etq5qow","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203969-etq5qow","updated":"20241015203969"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"final StringBuilder sb = new StringBuilder(\"Hello\");\nsb = new StringBuilder(\"World\"); // 报错，不能改变引用\nsb.append(\" World\"); // 允许，改变对象的内容\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20241015203970-qcbmufp","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015203970-qcbmufp","updated":"20241015203970"},"Children":[{"ID":"20241015203971-rbrpyc9","Type":"NodeParagraph","Properties":{"id":"20241015203971-rbrpyc9","updated":"20241015203971"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法"}]},{"ID":"20241015203972-2oiipzm","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203972-2oiipzm","updated":"20241015203972"},"Children":[{"ID":"20241015203973-k5jy7wy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203973-k5jy7wy","updated":"20241015203973"},"Children":[{"ID":"20241015203974-fxyy58x","Type":"NodeParagraph","Properties":{"id":"20241015203974-fxyy58x","updated":"20241015203974"},"Children":[{"Type":"NodeText","Data":"一个被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a strong","TextMarkTextContent":"不能被子类重写（override）"},{"Type":"NodeText","Data":"。这用于防止继承类对该方法的行为进行修改。"}]}]}]},{"ID":"20241015203975-lp13gdy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203975-lp13gdy","updated":"20241015203975"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"class Parent {\n    public final void show() {\n        System.out.println(\"This is a final method.\");\n    }\n}\n\nclass Child extends Parent {\n    // 不能重写 show() 方法，否则会编译错误\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]},{"ID":"20241015203976-giuhovf","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241015203976-giuhovf","updated":"20241015203976"},"Children":[{"ID":"20241015203977-beqsics","Type":"NodeParagraph","Properties":{"id":"20241015203977-beqsics","updated":"20241015203977"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 类"}]},{"ID":"20241015203978-bfdhcgp","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203978-bfdhcgp","updated":"20241015203978"},"Children":[{"ID":"20241015203979-31xb5sz","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203979-31xb5sz","updated":"20241015203979"},"Children":[{"ID":"20241015203980-mnatodr","Type":"NodeParagraph","Properties":{"id":"20241015203980-mnatodr","updated":"20241015203980"},"Children":[{"Type":"NodeText","Data":"一个被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰的类"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a strong","TextMarkTextContent":"不能被继承"},{"Type":"NodeText","Data":"。这通常用于设计不可改变的类，比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"String"},{"Type":"NodeText","Data":" 类就是一个典型的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 类。"}]}]}]},{"ID":"20241015203981-6jzxysd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015203981-6jzxysd","updated":"20241015203981"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public final class FinalClass {\n    // 该类不能被继承\n}\n\n// 下面这个声明会编译错误\n// class SubClass extends FinalClass {}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}]},{"ID":"20241015203982-jmp33p5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015203982-jmp33p5","updated":"20241015203982"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"Java 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 与 C++ 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 的对比"}]},{"ID":"20241015203983-mvef420","Type":"NodeList","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203983-mvef420","updated":"20241015203983"},"Children":[{"ID":"20241015203984-t1ycq16","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015203984-t1ycq16","updated":"20241015203984"},"Children":[{"ID":"20241015203985-rzmw00p","Type":"NodeParagraph","Properties":{"id":"20241015203985-rzmw00p","updated":"20241015203985"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 变量 vs "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"const"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 变量"}]},{"ID":"20241015203986-88i4a35","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203986-88i4a35","updated":"20241015203986"},"Children":[{"ID":"20241015203987-txna1k6","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203987-txna1k6","updated":"20241015203987"},"Children":[{"ID":"20241015203988-cg3xcrm","Type":"NodeParagraph","Properties":{"id":"20241015203988-cg3xcrm","updated":"20241015203988"},"Children":[{"Type":"NodeText","Data":"在 Java 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰变量的作用类似于 C++ 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":"，即变量的值一旦初始化后就不能改变。"}]}]},{"ID":"20241015203989-kj1uode","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203989-kj1uode","updated":"20241015203989"},"Children":[{"ID":"20241015203990-d7dm6qw","Type":"NodeParagraph","Properties":{"id":"20241015203990-d7dm6qw","updated":"20241015203990"},"Children":[{"Type":"NodeText","Data":"不同的是，C++ 中 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 可以用于指针来控制是否允许修改指针指向的对象或者指针本身："}]},{"ID":"20241015203991-b246xlv","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203991-b246xlv","updated":"20241015203991"},"Children":[{"ID":"20241015203992-ulpoes2","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203992-ulpoes2","updated":"20241015203992"},"Children":[{"ID":"20241015203993-mfw1rr5","Type":"NodeParagraph","Properties":{"id":"20241015203993-mfw1rr5","updated":"20241015203993"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const int* ptr"},{"Type":"NodeText","Data":"（指向常量的指针，不能通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ptr"},{"Type":"NodeText","Data":" 修改 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int"},{"Type":"NodeText","Data":" 的值，但 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ptr"},{"Type":"NodeText","Data":" 本身可以改变指向）。"}]}]},{"ID":"20241015203994-mag2ign","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203994-mag2ign","updated":"20241015203994"},"Children":[{"ID":"20241015203995-uagnu2f","Type":"NodeParagraph","Properties":{"id":"20241015203995-uagnu2f","updated":"20241015203995"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"int* const ptr"},{"Type":"NodeText","Data":"（常量指针，指针不能指向别的对象，但可以通过 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"ptr"},{"Type":"NodeText","Data":" 修改对象的值）。"}]}]}]}]}]},{"ID":"20241015203996-8d779hn","Type":"NodeParagraph","Properties":{"id":"20241015203996-8d779hn","updated":"20241015203996"},"Children":[{"Type":"NodeText","Data":"Java 没有指针语法，所以 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 引用只能控制引用本身是否可修改，不能控制引用对象的可变性。"}]}]},{"ID":"20241015203997-4pd6rm0","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015203997-4pd6rm0","updated":"20241015203997"},"Children":[{"ID":"20241015203998-6obrvx7","Type":"NodeParagraph","Properties":{"id":"20241015203998-6obrvx7","updated":"20241015203998"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"final"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法和类 vs C++ 中的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong code","TextMarkTextContent":"const"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":" 方法"}]},{"ID":"20241015203999-x6e49at","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015203999-x6e49at","updated":"20241015203999"},"Children":[{"ID":"20241015204000-at1buc0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204000-at1buc0","updated":"20241015204000"},"Children":[{"ID":"20241015204001-0nztmw1","Type":"NodeParagraph","Properties":{"id":"20241015204001-0nztmw1","updated":"20241015204001"},"Children":[{"Type":"NodeText","Data":"C++ 中有 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 方法，这意味着该方法不能修改对象的状态。Java 中没有直接对应的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 方法，但可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 来禁止方法被子类重写，而不是限制其修改状态。"}]}]},{"ID":"20241015204002-ydo886a","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204002-ydo886a","updated":"20241015204002"},"Children":[{"ID":"20241015204003-9d8yta9","Type":"NodeParagraph","Properties":{"id":"20241015204003-9d8yta9","updated":"20241015204003"},"Children":[{"Type":"NodeText","Data":"C++ 中没有类似 Java 的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 修饰符用于防止类继承，但 C++ 可以通过其他方式（如使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":" 构造函数或虚函数机制）来实现类似效果。"}]}]}]}]}]},{"ID":"20241015204004-rhgu72r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204004-rhgu72r","updated":"20241015204004"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeText","Data":"总结"}]},{"ID":"20241015204005-yycgpnu","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204005-yycgpnu","updated":"20241015204005"},"Children":[{"ID":"20241015204006-0pkeazc","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204006-0pkeazc","updated":"20241015204006"},"Children":[{"ID":"20241015204007-pg5kzfd","Type":"NodeParagraph","Properties":{"id":"20241015204007-pg5kzfd","updated":"20241015204007"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"Java"},{"Type":"NodeText","Data":" 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 主要用于限制修改：它可以用于变量（不可变变量）、方法（不可重写方法）、类（不可继承类）。"}]}]},{"ID":"20241015204008-25k3qr0","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204008-25k3qr0","updated":"20241015204008"},"Children":[{"ID":"20241015204009-9rgg9qz","Type":"NodeParagraph","Properties":{"id":"20241015204009-9rgg9qz","updated":"20241015204009"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"C++"},{"Type":"NodeText","Data":" 中，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":" 主要用于定义不可变的变量或对象，并且可以更细粒度地控制指针和方法的行为。"}]}]}]}]}]},{"ID":"20241015204010-177z01c","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204010-177z01c","updated":"20241015204010"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#静态变量有什么作用","TextMarkTextContent":"静态变量有什么作用？"}]},{"ID":"20241015204011-576j0by","Type":"NodeParagraph","Properties":{"id":"20241015204011-576j0by","updated":"20241015204011"},"Children":[{"Type":"NodeText","Data":"静态变量也就是被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。"}]},{"ID":"20241015204012-qgm1gxf","Type":"NodeParagraph","Properties":{"id":"20241015204012-qgm1gxf","updated":"20241015204012"},"Children":[{"Type":"NodeText","Data":"静态变量是通过类名来访问的，例如"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StaticVariableExample.staticVar"},{"Type":"NodeText","Data":"（如果被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private"},{"Type":"NodeText","Data":"关键字修饰就无法这样访问了）。"}]},{"ID":"20241015204013-ezn1q8p","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204013-ezn1q8p","updated":"20241015204013"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class StaticVariableExample {\n    // 静态变量\n    public static int staticVar = 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204014-ibubmm3","Type":"NodeParagraph","Properties":{"id":"20241015204014-ibubmm3","updated":"20241015204014"},"Children":[{"Type":"NodeText","Data":"通常情况下，静态变量会被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":" 关键字修饰成为常量。"}]},{"ID":"20241015204015-yec6bsq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204015-yec6bsq","updated":"20241015204015"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class ConstantVariableExample {\n    // 常量\n    public static final int constantVar = 0;\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204016-mc5gkzl","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204016-mc5gkzl","updated":"20241015204016"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#字符型常量和字符串常量的区别","TextMarkTextContent":"字符型常量和字符串常量的区别?"}]},{"ID":"20241015204017-22jiyjz","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204017-22jiyjz","updated":"20241015204017"},"Children":[{"ID":"20241015204018-m44a6ss","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204018-m44a6ss","updated":"20241015204018"},"Children":[{"ID":"20241015204019-r2jubpr","Type":"NodeParagraph","Properties":{"id":"20241015204019-r2jubpr","updated":"20241015204019"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"形式"},{"Type":"NodeText","Data":" : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。"}]}]},{"ID":"20241015204020-fdbdpcy","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204020-fdbdpcy","updated":"20241015204020"},"Children":[{"ID":"20241015204021-ynaa8cv","Type":"NodeParagraph","Properties":{"id":"20241015204021-ynaa8cv","updated":"20241015204021"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"含义"},{"Type":"NodeText","Data":" : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。"}]}]},{"ID":"20241015204022-cbmhqqa","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204022-cbmhqqa","updated":"20241015204022"},"Children":[{"ID":"20241015204023-3yzhn0k","Type":"NodeParagraph","Properties":{"id":"20241015204023-3yzhn0k","updated":"20241015204023"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"占内存大小"},{"Type":"NodeText","Data":"：字符常量只占 2 个字节; 字符串常量占若干个字节。"}]}]}]},{"ID":"20241015204024-y2pm4py","Type":"NodeParagraph","Properties":{"id":"20241015204024-y2pm4py","updated":"20241015204024"},"Children":[{"Type":"NodeText","Data":"⚠️ 注意 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"char"},{"Type":"NodeText","Data":" 在 Java 中占两个字节。"}]},{"ID":"20241015204025-j7319er","Type":"NodeParagraph","Properties":{"id":"20241015204025-j7319er","updated":"20241015204025"},"Children":[{"Type":"NodeText","Data":"字符型常量和字符串常量代码示例："}]},{"ID":"20241015204026-usb6g7l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204026-usb6g7l","updated":"20241015204026"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class StringExample {\n    // 字符型常量\n    public static final char LETTER_A = 'A';\n\n    // 字符串常量\n    public static final String GREETING_MESSAGE = \"Hello, world!\";\n    public static void main(String[] args) {\n        System.out.println(\"字符型常量占用的字节数为：\"+Character.BYTES);\n        System.out.println(\"字符串常量占用的字节数为：\"+GREETING_MESSAGE.getBytes().length);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204027-o2t2y17","Type":"NodeParagraph","Properties":{"id":"20241015204027-o2t2y17","updated":"20241015204027"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20241015204028-40qf0mm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204028-40qf0mm","updated":"20241015204028"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"字符型常量占用的字节数为：2\n字符串常量占用的字节数为：13\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204029-pqow42n","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20241015204029-pqow42n","updated":"20241015204029"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## ","Properties":{"id":""}},{"Type":"NodeText","Data":"方法"}]},{"ID":"20241015204030-d2eh5ko","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204030-d2eh5ko","updated":"20241015204030"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#静态方法为什么不能调用非静态成员","TextMarkTextContent":"静态方法为什么不能调用非静态成员?"}]},{"ID":"20241015204031-d34mvla","Type":"NodeParagraph","Properties":{"id":"20241015204031-d34mvla","updated":"20241015204031"},"Children":[{"Type":"NodeText","Data":"这个需要结合 JVM 的相关知识，主要原因如下："}]},{"ID":"20241015204032-ktl6b0g","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015204032-ktl6b0g","updated":"20241015204032"},"Children":[{"ID":"20241015204033-ikixsbp","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015204033-ikixsbp","updated":"20241015204033"},"Children":[{"ID":"20241015204034-ie0udj4","Type":"NodeParagraph","Properties":{"id":"20241015204034-ie0udj4","updated":"20241015204034"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"静态方法是属于类的，在类加载的时候就会分配内存"},{"Type":"NodeText","Data":"，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。"}]}]},{"ID":"20241015204035-15rhw1m","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015204035-15rhw1m","updated":"20241015204035"},"Children":[{"ID":"20241015204036-qk38vc2","Type":"NodeParagraph","Properties":{"id":"20241015204036-qk38vc2","updated":"20241015204036"},"Children":[{"Type":"NodeText","Data":"在"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"类的非静态成员不存在的时候静态方法就已经存在了"},{"Type":"NodeText","Data":"，此时调用在内存中还不存在的非静态成员，属于非法操作。"}]}]}]},{"ID":"20241015204037-axxsd53","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204037-axxsd53","updated":"20241015204037"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Example {\n    // 定义一个字符型常量\n    public static final char LETTER_A = 'A';\n\n    // 定义一个字符串常量\n    public static final String GREETING_MESSAGE = \"Hello, world!\";\n\n    public static void main(String[] args) {\n        // 输出字符型常量的值\n        System.out.println(\"字符型常量的值为：\" + LETTER_A);\n\n        // 输出字符串常量的值\n        System.out.println(\"字符串常量的值为：\" + GREETING_MESSAGE);\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204038-475yff1","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204038-475yff1","updated":"20241015204038"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#静态方法和实例方法有何不同","TextMarkTextContent":"静态方法和实例方法有何不同？"}]},{"ID":"20241015204039-qiwyles","Type":"NodeParagraph","Properties":{"id":"20241015204039-qiwyles","updated":"20241015204039"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"1、调用方式"}]},{"ID":"20241015204040-cowghc4","Type":"NodeParagraph","Properties":{"id":"20241015204040-cowghc4","updated":"20241015204040"},"Children":[{"Type":"NodeText","Data":"在外部调用静态方法时，可以使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式，也"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"可以"},{"Type":"NodeText","Data":"使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式，而实例方法只有后面这种方式。也就是说，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"调用静态方法可以无需创建对象"},{"Type":"NodeText","Data":" 。"}]},{"ID":"20241015204041-7fibcd2","Type":"NodeParagraph","Properties":{"id":"20241015204041-7fibcd2","updated":"20241015204041"},"Children":[{"Type":"NodeText","Data":"不过，需要注意的是一般不建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"对象.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。"}]},{"ID":"20241015204042-t55p0dt","Type":"NodeParagraph","Properties":{"id":"20241015204042-t55p0dt","updated":"20241015204042"},"Children":[{"Type":"NodeText","Data":"因此，一般建议使用 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"类名.方法名"},{"Type":"NodeText","Data":" 的方式来调用静态方法。"}]},{"ID":"20241015204043-g4j5vzg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204043-g4j5vzg","updated":"20241015204043"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Person {\n    public void method() {\n      //......\n    }\n\n    public static void staicMethod(){\n      //......\n    }\n    public static void main(String[] args) {\n        Person person = new Person();\n        // 调用实例方法\n        person.method();\n        // 调用静态方法\n        Person.staicMethod()\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204044-tu8tka1","Type":"NodeParagraph","Properties":{"id":"20241015204044-tu8tka1","updated":"20241015204044"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"2、访问类成员是否存在限制"}]},{"ID":"20241015204045-cu82yak","Type":"NodeParagraph","Properties":{"id":"20241015204045-cu82yak","updated":"20241015204045"},"Children":[{"Type":"NodeText","Data":"静态方法在访问本类的成员时，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkTextContent":"只允许访问静态成员"},{"Type":"NodeText","Data":"（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。"}]},{"ID":"20241015204046-dkmvj4r","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204046-dkmvj4r","updated":"20241015204046"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#重载和重写有什么区别","TextMarkTextContent":"重载和重写有什么区别？"}]},{"ID":"20241015204047-ljm7m80","Type":"NodeBlockquote","Properties":{"id":"20241015204047-ljm7m80","updated":"20241015204047"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015204048-ettggtp","Type":"NodeParagraph","Properties":{"id":"20241015204048-ettggtp","updated":"20241015204048"},"Children":[{"Type":"NodeText","Data":"重载就是同样的一个方法能够"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"根据输入数据的不同"},{"Type":"NodeText","Data":"，做出不同的处理"}]},{"ID":"20241015204049-32om7iq","Type":"NodeParagraph","Properties":{"id":"20241015204049-32om7iq","updated":"20241015204049"},"Children":[{"Type":"NodeText","Data":"重写就是当子类继承自父类的相同方法，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"输入数据一样"},{"Type":"NodeText","Data":"，但要"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"做出有别于父类的响应时"},{"Type":"NodeText","Data":"，你就要覆盖父类方法"}]}]},{"ID":"20241015204050-7a0jkaw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241015204050-7a0jkaw","updated":"20241015204050"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#重载","TextMarkTextContent":"重载"}]},{"ID":"20241015204051-wiofa60","Type":"NodeParagraph","Properties":{"id":"20241015204051-wiofa60","updated":"20241015204051"},"Children":[{"Type":"NodeText","Data":"发生在同一个类中（或者父类和子类之间），=="},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法名必须相同"},{"Type":"NodeText","Data":"✅，参数类型不同、个数不同、顺序不同✅，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法返回值和访问修饰符可以不同"},{"Type":"NodeText","Data":"==✅-"}]},{"ID":"20241015204052-2lwosvv","Type":"NodeParagraph","Properties":{"id":"20241015204052-2lwosvv","updated":"20241015204052"},"Children":[{"Type":"NodeText","Data":"《Java 核心技术》这本书是这样介绍重载的："}]},{"ID":"20241015204053-cu5ilcp","Type":"NodeBlockquote","Properties":{"id":"20241015204053-cu5ilcp","updated":"20241015204053"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e ","Properties":{"id":""}},{"ID":"20241015204054-wv9g95r","Type":"NodeParagraph","Properties":{"id":"20241015204054-wv9g95r","updated":"20241015204054"},"Children":[{"Type":"NodeText","Data":"如果多个方法(比如 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"StringBuilder"},{"Type":"NodeText","Data":" 的构造方法)有相同的名字、不同的参数， 便产生了重载。"}]},{"ID":"20241015204055-5hhibjl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204055-5hhibjl","updated":"20241015204055"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"StringBuilder sb = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(\"HelloWorld\");\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204056-zygwkfi","Type":"NodeParagraph","Properties":{"id":"20241015204056-zygwkfi","updated":"20241015204056"},"Children":[{"Type":"NodeText","Data":"编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。"}]},{"ID":"20241015204057-3w5wm9a","Type":"NodeParagraph","Properties":{"id":"20241015204057-3w5wm9a","updated":"20241015204057"},"Children":[{"Type":"NodeText","Data":"Java 允许重载任何方法， 而不只是构造器方法。"}]}]},{"ID":"20241015204058-9iowax6","Type":"NodeParagraph","Properties":{"id":"20241015204058-9iowax6","updated":"20241015204058"},"Children":[{"Type":"NodeText","Data":"综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。"}]},{"ID":"20241015204059-32rjhma","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20241015204059-32rjhma","updated":"20241015204059"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#重写","TextMarkTextContent":"重写"}]},{"ID":"20241015204060-7coxxhy","Type":"NodeParagraph","Properties":{"id":"20241015204060-7coxxhy","updated":"20241015204060"},"Children":[{"Type":"NodeText","Data":"重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。"}]},{"ID":"20241015204061-0gywui5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015204061-0gywui5","updated":"20241015204061"},"Children":[{"ID":"20241015204062-a761b6s","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20241015204062-a761b6s","updated":"20241015204062"},"Children":[{"ID":"20241015204063-jp37a6i","Type":"NodeParagraph","Properties":{"id":"20241015204063-jp37a6i","updated":"20241015204063"},"Children":[{"Type":"NodeText","Data":"方法名、参数列表必须相同，==子类方法返回值类型应比父类方法"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"返回值类型更小或相等"},{"Type":"NodeText","Data":"(协变返回类型:子类方法可以返回父类方法返回值类型的子类（更具体的类型）)，抛出的"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"异常范围小于等于父类"},{"Type":"NodeText","Data":"，访问"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"修饰符范围大于等于父类"},{"Type":"NodeText","Data":"==。"}]}]},{"ID":"20241015204064-fqs4sgx","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20241015204064-fqs4sgx","updated":"20241015204064"},"Children":[{"ID":"20241015204065-xfudb0d","Type":"NodeParagraph","Properties":{"id":"20241015204065-xfudb0d","updated":"20241015204065"},"Children":[{"Type":"NodeText","Data":"如果父类方法访问修饰符为 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"private/final/static"},{"Type":"NodeText","Data":" 则子类就不能重写该方法，但是被 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"static"},{"Type":"NodeText","Data":" 修饰的方法能够被再次声明。"}]}]},{"ID":"20241015204066-r44knek","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20241015204066-r44knek","updated":"20241015204066"},"Children":[{"ID":"20241015204067-l0lzyib","Type":"NodeParagraph","Properties":{"id":"20241015204067-l0lzyib","updated":"20241015204067"},"Children":[{"Type":"NodeText","Data":"构造方法无法被重写"}]}]}]},{"ID":"20241015204068-eude8bf","Type":"NodeParagraph","Properties":{"id":"20241015204068-eude8bf","updated":"20241015204068"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#总结","TextMarkTextContent":"总结"}]},{"ID":"20241015204069-scnc0xp","Type":"NodeParagraph","Properties":{"id":"20241015204069-scnc0xp","updated":"20241015204069"},"Children":[{"Type":"NodeText","Data":"综上："},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。"}]},{"ID":"20241015204070-xoyv1k1","Type":"NodeTable","Data":"| 区别点     | 重载方法 | 重写方法                                                     |\n| :--------- | :------- | :----------------------------------------------------------- |\n| 发生范围   | 同一个类 | 子类                                                         |\n| 参数列表   | 必须修改 | 一定不能修改                                                 |\n| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |\n| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |\n| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |\n| 发生阶段   | 编译期   | 运行期                                                       |","TableAligns":[1,1,1],"Properties":{"id":"20241015204070-xoyv1k1","updated":"20241015204070"},"Children":[{"Type":"NodeTableHead","Properties":{"id":""},"Children":[{"Type":"NodeTableRow","Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"区别点"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重载方法"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"重写方法"}]}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生范围"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"同一个类"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"参数列表"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"必须修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能修改"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"返回类型"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法返回值类型应比父类方法返回值类型更小或相等"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"异常"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"访问修饰符"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"可修改"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"一定不能做更严格的限制（可以降低限制）"}]}]},{"Type":"NodeTableRow","TableAligns":[1,1,1],"Properties":{"id":""},"Children":[{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"发生阶段"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"编译期"}]},{"Type":"NodeTableCell","TableCellAlign":1,"Properties":{"id":""},"Children":[{"Type":"NodeText","Data":"运行期"}]}]}]},{"ID":"20241015204071-9c1x8y6","Type":"NodeParagraph","Properties":{"id":"20241015204071-9c1x8y6","updated":"20241015204071"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"方法的重写要遵循“两同两小一大”"},{"Type":"NodeText","Data":"（以下内容摘录自《疯狂 Java 讲义》，"},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://github.com/Snailclimb/JavaGuide/issues/892","TextMarkTextContent":"issue#892open in new window"},{"Type":"NodeText","Data":" ）："}]},{"ID":"20241015204072-v7pn8qn","Type":"NodeList","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204072-v7pn8qn","updated":"20241015204072"},"Children":[{"ID":"20241015204073-69gnpjs","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204073-69gnpjs","updated":"20241015204073"},"Children":[{"ID":"20241015204074-umi893s","Type":"NodeParagraph","Properties":{"id":"20241015204074-umi893s","updated":"20241015204074"},"Children":[{"Type":"NodeText","Data":"“两同”即方法名相同、形参列表相同；"}]}]},{"ID":"20241015204075-j86qn2r","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204075-j86qn2r","updated":"20241015204075"},"Children":[{"ID":"20241015204076-iyrvx9h","Type":"NodeParagraph","Properties":{"id":"20241015204076-iyrvx9h","updated":"20241015204076"},"Children":[{"Type":"NodeText","Data":"“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；"}]}]},{"ID":"20241015204077-o01uhwt","Type":"NodeListItem","Data":"-","ListData":{"Tight":true,"BulletChar":45,"Padding":2,"Marker":"LQ==","Num":-1},"Properties":{"id":"20241015204077-o01uhwt","updated":"20241015204077"},"Children":[{"ID":"20241015204078-lfk9mz4","Type":"NodeParagraph","Properties":{"id":"20241015204078-lfk9mz4","updated":"20241015204078"},"Children":[{"Type":"NodeText","Data":"“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。"}]}]}]},{"ID":"20241015204079-8jgeapa","Type":"NodeParagraph","Properties":{"id":"20241015204079-8jgeapa","updated":"20241015204079"},"Children":[{"Type":"NodeText","Data":"⭐️ 关于 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"重写的返回值类型"},{"Type":"NodeText","Data":" 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。"}]},{"ID":"20241015204080-97088p3","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204080-97088p3","updated":"20241015204080"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class Hero {\n    public String name() {\n        return \"超级英雄\";\n    }\n}\npublic class SuperMan extends Hero{\n    @Override\n    public String name() {\n        return \"超人\";\n    }\n    public Hero hero() {\n        return new Hero();\n    }\n}\n\npublic class SuperSuperMan extends SuperMan {\n    @Override\n    public String name() {\n        return \"超级超级英雄\";\n    }\n\n    @Override\n    public SuperMan hero() {\n        return new SuperMan();\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204081-0duvtxa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20241015204081-0duvtxa","updated":"20241015204081"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### ","Properties":{"id":""}},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"a","TextMarkAHref":"https://javaguide.cn/java/basis/java-basic-questions-01.html#什么是可变长参数","TextMarkTextContent":"什么是可变长参数？"}]},{"ID":"20241015204082-ni3d0ek","Type":"NodeParagraph","Properties":{"id":"20241015204082-ni3d0ek","updated":"20241015204082"},"Children":[{"Type":"NodeText","Data":"从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。"}]},{"ID":"20241015204083-q870d4w","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204083-q870d4w","updated":"20241015204083"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method1(String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204084-f75e4mf","Type":"NodeParagraph","Properties":{"id":"20241015204084-f75e4mf","updated":"20241015204084"},"Children":[{"Type":"NodeText","Data":"另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。"}]},{"ID":"20241015204085-v17igsn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204085-v17igsn","updated":"20241015204085"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public static void method2(String arg1, String... args) {\n   //......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204086-5e2nl8z","Type":"NodeParagraph","Properties":{"id":"20241015204086-5e2nl8z","updated":"20241015204086"},"Children":[{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"strong","TextMarkTextContent":"遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？"}]},{"ID":"20241015204087-5adzm0j","Type":"NodeParagraph","Properties":{"id":"20241015204087-5adzm0j","updated":"20241015204087"},"Children":[{"Type":"NodeText","Data":"答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。"}]},{"ID":"20241015204088-91h8em9","Type":"NodeParagraph","Properties":{"id":"20241015204088-91h8em9","updated":"20241015204088"},"Children":[{"Type":"NodeText","Data":"我们通过下面这个例子来证明一下。"}]},{"ID":"20241015204089-m8ev0qg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204089-m8ev0qg","updated":"20241015204089"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"/**\n * 微信搜 JavaGuide 回复\"面试突击\"即可免费领取个人原创的 Java 面试手册\n *\n * @author Guide哥\n * @date 2021/12/13 16:52\n **/\npublic class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        for (String s : args) {\n            System.out.println(s);\n        }\n    }\n\n    public static void printVariable(String arg1, String arg2) {\n        System.out.println(arg1 + arg2);\n    }\n\n    public static void main(String[] args) {\n        printVariable(\"a\", \"b\");\n        printVariable(\"a\", \"b\", \"c\", \"d\");\n    }\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204090-u78wqn7","Type":"NodeParagraph","Properties":{"id":"20241015204090-u78wqn7","updated":"20241015204090"},"Children":[{"Type":"NodeText","Data":"输出："}]},{"ID":"20241015204091-o5ahaj0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"cGxhaW4=","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204091-o5ahaj0","updated":"20241015204091"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cGxhaW4=","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"ab\na\nb\nc\nd\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]},{"ID":"20241015204092-f0lb63l","Type":"NodeParagraph","Properties":{"id":"20241015204092-f0lb63l","updated":"20241015204092"},"Children":[{"Type":"NodeText","Data":"另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 "},{"Type":"NodeTextMark","Properties":{"id":""},"TextMarkType":"code","TextMarkTextContent":"class"},{"Type":"NodeText","Data":"文件就可以看出来了。"}]},{"ID":"20241015204093-nf9mrkx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"amF2YQ==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20241015204093-nf9mrkx","updated":"20241015204093"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ==","Properties":{"id":""}},{"Type":"NodeCodeBlockCode","Data":"public class VariableLengthArgument {\n\n    public static void printVariable(String... args) {\n        String[] var1 = args;\n        int var2 = args.length;\n\n        for(int var3 = 0; var3 \u003c var2; ++var3) {\n            String s = var1[var3];\n            System.out.println(s);\n        }\n\n    }\n    // ......\n}\n","Properties":{"id":""}},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3,"Properties":{"id":""}}]}]}